{"ast":null,"code":"/**\n * Player Physics System\n * Handles player movement, gravity, jumping, and bouncing\n */import{PLAYER_HORIZONTAL_RANGE_LEFT,PLAYER_HORIZONTAL_RANGE_RIGHT,GRAVITY,ENERGY_LOSS,BOOST,HOLD_BOOST,MAX_HOLD_TIME,MIN_BOUNCE_VELOCITY}from'../config/gameConfig';export class PlayerPhysics{constructor(initialX,initialY,centerY){this.playerState=void 0;this.initialX=void 0;this.centerY=void 0;this.centerY=centerY;this.initialX=initialX;this.playerState={position:{x:initialX,y:initialY},velocity:0,scaleX:1,scaleY:1,hasJumped:false,isHolding:false,holdStartTime:0};}/**\n   * Update player physics for one frame\n   */update(){// Apply gravity\nthis.playerState.velocity-=GRAVITY;// Apply hold boost\nif(this.playerState.isHolding){const heldTime=performance.now()-this.playerState.holdStartTime;if(heldTime<MAX_HOLD_TIME){this.playerState.velocity+=HOLD_BOOST;}else{this.playerState.isHolding=false;}}// Update position\nthis.playerState.position.y-=this.playerState.velocity;// Handle floor collision (bounce)\nif(this.playerState.position.y>this.centerY){this.playerState.position.y=this.centerY;this.playerState.velocity=-this.playerState.velocity*ENERGY_LOSS;this.playerState.hasJumped=false;// Stop very small bounces\nif(Math.abs(this.playerState.velocity)<MIN_BOUNCE_VELOCITY){this.playerState.velocity=0;}}// Handle ceiling collision\nif(this.playerState.position.y<0){this.playerState.position.y=0;this.playerState.velocity=-this.playerState.velocity*ENERGY_LOSS;}// Update fluid scaling based on velocity and position\nthis.updateScaling();return this.playerState;}/**\n   * Update player's horizontal position based on mouse/touch input.\n   * @param clientX The mouse's X coordinate.\n   * @param screenWidth The total width of the screen.\n   */setMousePosition(clientX,screenWidth){const mouseRatio=clientX/screenWidth;// Mouse position as a ratio from 0.0 to 1.0\nconst minX=this.initialX-PLAYER_HORIZONTAL_RANGE_LEFT;const maxX=this.initialX+PLAYER_HORIZONTAL_RANGE_RIGHT;this.playerState.position.x=minX+mouseRatio*(maxX-minX);}/**\n   * Start a jump (initial press)\n   */startJump(){if(!this.playerState.hasJumped){this.playerState.velocity=BOOST;this.playerState.hasJumped=true;}this.playerState.isHolding=true;this.playerState.holdStartTime=performance.now();}/**\n   * Stop holding jump\n   */endJump(){this.playerState.isHolding=false;}/**\n   * Update player scaling for squash and stretch effect\n   */updateScaling(){let targetScaleX=1;let targetScaleY=1;if(Math.abs(this.playerState.velocity)>0.1){if(this.playerState.velocity>0){// Moving up - stretch vertically\ntargetScaleY=1-this.playerState.velocity/50;targetScaleX=1+this.playerState.velocity/50;}else{// Moving down - stretch horizontally\ntargetScaleY=1+Math.abs(this.playerState.velocity)/50;targetScaleX=1-Math.abs(this.playerState.velocity)/50;}}// Squash when on ground\nif(this.playerState.position.y>=this.centerY&&Math.abs(this.playerState.velocity)<0.5){targetScaleY=0.7;targetScaleX=1.3;}// Return to normal when settled\nif(Math.abs(this.playerState.velocity)<0.01&&this.playerState.position.y>=this.centerY){targetScaleX=1;targetScaleY=1;}// Smooth interpolation\nthis.playerState.scaleX+=(targetScaleX-this.playerState.scaleX)*0.15;this.playerState.scaleY+=(targetScaleY-this.playerState.scaleY)*0.15;}/**\n   * Check if player should trigger a bounce sound\n   */shouldPlayBounceSound(){return this.playerState.position.y>=this.centerY&&Math.abs(this.playerState.velocity)>MIN_BOUNCE_VELOCITY;}/**\n   * Get bounce volume based on velocity\n   */getBounceVolume(){return Math.min(Math.abs(this.playerState.velocity)/BOOST,1);}/**\n   * Reset player to initial state\n   */reset(initialX,initialY){this.initialX=initialX;this.playerState={position:{x:initialX,y:initialY},velocity:0,scaleX:1,scaleY:1,hasJumped:false,isHolding:false,holdStartTime:0};}/**\n   * Update center Y (for window resize)\n   */updateCenterY(newCenterY){this.centerY=newCenterY;// When resizing, we don't want to snap back to the initial Y if we're in the air\nthis.playerState.position.y=newCenterY;}/**\n   * Get current player state\n   */getState(){return this.playerState;}/**\n   * Check if player has jumped (for scoring)\n   */hasPlayerJumped(){return this.playerState.hasJumped;}}","map":{"version":3,"names":["PLAYER_HORIZONTAL_RANGE_LEFT","PLAYER_HORIZONTAL_RANGE_RIGHT","GRAVITY","ENERGY_LOSS","BOOST","HOLD_BOOST","MAX_HOLD_TIME","MIN_BOUNCE_VELOCITY","PlayerPhysics","constructor","initialX","initialY","centerY","playerState","position","x","y","velocity","scaleX","scaleY","hasJumped","isHolding","holdStartTime","update","heldTime","performance","now","Math","abs","updateScaling","setMousePosition","clientX","screenWidth","mouseRatio","minX","maxX","startJump","endJump","targetScaleX","targetScaleY","shouldPlayBounceSound","getBounceVolume","min","reset","updateCenterY","newCenterY","getState","hasPlayerJumped"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/playerPhysics.ts"],"sourcesContent":["/**\n * Player Physics System\n * Handles player movement, gravity, jumping, and bouncing\n */\n\nimport { PlayerState } from '../types/game';\nimport {\n  PLAYER_HORIZONTAL_RANGE_LEFT,\n  PLAYER_HORIZONTAL_RANGE_RIGHT,\n  GRAVITY,\n  ENERGY_LOSS,\n  BOOST,\n  HOLD_BOOST,\n  MAX_HOLD_TIME,\n  MIN_BOUNCE_VELOCITY,\n} from '../config/gameConfig';\n\nexport class PlayerPhysics {\n  private playerState: PlayerState;\n  private initialX: number;\n  private centerY: number;\n\n  constructor(initialX: number, initialY: number, centerY: number) {\n    this.centerY = centerY;\n    this.initialX = initialX;\n    this.playerState = {\n      position: { x: initialX, y: initialY },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0,\n    };\n  }\n\n  /**\n   * Update player physics for one frame\n   */\n  update(): PlayerState {\n    // Apply gravity\n    this.playerState.velocity -= GRAVITY;\n\n    // Apply hold boost\n    if (this.playerState.isHolding) {\n      const heldTime = performance.now() - this.playerState.holdStartTime;\n      if (heldTime < MAX_HOLD_TIME) {\n        this.playerState.velocity += HOLD_BOOST;\n      } else {\n        this.playerState.isHolding = false;\n      }\n    }\n\n    // Update position\n    this.playerState.position.y -= this.playerState.velocity;\n\n    // Handle floor collision (bounce)\n    if (this.playerState.position.y > this.centerY) {\n      this.playerState.position.y = this.centerY;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n      this.playerState.hasJumped = false;\n\n      // Stop very small bounces\n      if (Math.abs(this.playerState.velocity) < MIN_BOUNCE_VELOCITY) {\n        this.playerState.velocity = 0;\n      }\n    }\n\n    // Handle ceiling collision\n    if (this.playerState.position.y < 0) {\n      this.playerState.position.y = 0;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n    }\n\n    // Update fluid scaling based on velocity and position\n    this.updateScaling();\n\n    return this.playerState;\n  }\n\n  /**\n   * Update player's horizontal position based on mouse/touch input.\n   * @param clientX The mouse's X coordinate.\n   * @param screenWidth The total width of the screen.\n   */\n  setMousePosition(clientX: number, screenWidth: number): void {\n    const mouseRatio = clientX / screenWidth; // Mouse position as a ratio from 0.0 to 1.0\n    const minX = this.initialX - PLAYER_HORIZONTAL_RANGE_LEFT;\n    const maxX = this.initialX + PLAYER_HORIZONTAL_RANGE_RIGHT;\n    this.playerState.position.x = minX + (mouseRatio * (maxX - minX));\n  }\n\n  /**\n   * Start a jump (initial press)\n   */\n  startJump(): void {\n    if (!this.playerState.hasJumped) {\n      this.playerState.velocity = BOOST;\n      this.playerState.hasJumped = true;\n    }\n    this.playerState.isHolding = true;\n    this.playerState.holdStartTime = performance.now();\n  }\n\n  /**\n   * Stop holding jump\n   */\n  endJump(): void {\n    this.playerState.isHolding = false;\n  }\n\n  /**\n   * Update player scaling for squash and stretch effect\n   */\n  private updateScaling(): void {\n    let targetScaleX = 1;\n    let targetScaleY = 1;\n\n    if (Math.abs(this.playerState.velocity) > 0.1) {\n      if (this.playerState.velocity > 0) {\n        // Moving up - stretch vertically\n        targetScaleY = 1 - this.playerState.velocity / 50;\n        targetScaleX = 1 + this.playerState.velocity / 50;\n      } else {\n        // Moving down - stretch horizontally\n        targetScaleY = 1 + Math.abs(this.playerState.velocity) / 50;\n        targetScaleX = 1 - Math.abs(this.playerState.velocity) / 50;\n      }\n    }\n\n    // Squash when on ground\n    if (\n      this.playerState.position.y >= this.centerY &&\n      Math.abs(this.playerState.velocity) < 0.5\n    ) {\n      targetScaleY = 0.7;\n      targetScaleX = 1.3;\n    }\n\n    // Return to normal when settled\n    if (\n      Math.abs(this.playerState.velocity) < 0.01 &&\n      this.playerState.position.y >= this.centerY\n    ) {\n      targetScaleX = 1;\n      targetScaleY = 1;\n    }\n\n    // Smooth interpolation\n    this.playerState.scaleX += (targetScaleX - this.playerState.scaleX) * 0.15;\n    this.playerState.scaleY += (targetScaleY - this.playerState.scaleY) * 0.15;\n  }\n\n  /**\n   * Check if player should trigger a bounce sound\n   */\n  shouldPlayBounceSound(): boolean {\n    return (\n      this.playerState.position.y >= this.centerY &&\n      Math.abs(this.playerState.velocity) > MIN_BOUNCE_VELOCITY\n    );\n  }\n\n  /**\n   * Get bounce volume based on velocity\n   */\n  getBounceVolume(): number {\n    return Math.min(Math.abs(this.playerState.velocity) / BOOST, 1);\n  }\n\n  /**\n   * Reset player to initial state\n   */\n  reset(initialX: number, initialY: number): void {\n    this.initialX = initialX;\n    this.playerState = {\n      position: { x: initialX, y: initialY },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0,\n    };\n  }\n\n  /**\n   * Update center Y (for window resize)\n   */\n  updateCenterY(newCenterY: number): void {\n    this.centerY = newCenterY;\n    // When resizing, we don't want to snap back to the initial Y if we're in the air\n    this.playerState.position.y = newCenterY;\n  }\n\n  /**\n   * Get current player state\n   */\n  getState(): PlayerState {\n    return this.playerState;\n  }\n\n  /**\n   * Check if player has jumped (for scoring)\n   */\n  hasPlayerJumped(): boolean {\n    return this.playerState.hasJumped;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}