{"ast":null,"code":"/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */\n\nimport { LASER_WIDTH, LASER_HEIGHT, BASE_LASER_SPEED, LASER_SPEED_INCREMENT, LASER_SPEED_REDUCTION_ON_UNLOCK, LASER_SPEED_GRADUAL_REDUCTION, LASER_SPEED_AT_SCORE_50, LASER_SPEED_AT_SCORE_75, LASER_SPEED_TRANSITION_DURATION, MAX_LASERS, SCORE_PER_LASER_UNLOCK, SCORE_PER_SPEED_INCREMENT, BALL_SIZE, ENEMY_MOVE_SPEED, ENEMY_MOVEMENT_DELAY, ENEMY_SETTLE_THRESHOLD, ENEMY_BOUNCE_AMPLITUDE, ENEMY_OSCILLATION_DAMPING, ENEMY_MIN_OSCILLATION_VELOCITY, CHAOS_INCREMENT_INTERVAL, BASE_LASER_RANDOMNESS, CHAOS_MULTIPLIER_PER_INTERVAL } from '../config/gameConfig';\nimport { ENEMY_WIDTH_GROWTH_PER_CYCLE, ENEMY_HEIGHT_GROWTH_PER_CYCLE } from '../config/gameConfig';\nexport class LaserPhysics {\n  constructor(screenWidth, screenHeight, centerY, enemyX) {\n    this.lasers = [];\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.speedResetScore = -1;\n    // Track when speed was last reset (for score 50 logic)\n    this.isTransitioningSpeed = false;\n    // Track if speed is currently transitioning\n    this.transitionStartSpeed = 0;\n    // Speed at start of transition\n    this.transitionTargetSpeed = 0;\n    // Target speed for transition\n    this.transitionProgress = 0;\n    // Progress of transition (0 to 1)\n    this.enemyY = void 0;\n    this.targetEnemyY = void 0;\n    // Target Y position for smooth movement\n    this.pendingTargetY = null;\n    // Delayed target position\n    this.movementDelayTimer = 0;\n    // Timer for movement delay\n    this.enemyVelocity = 0;\n    // Track movement velocity for squash/stretch\n    this.oscillationVelocity = 0;\n    // Velocity for settling bounce/oscillation\n    this.isSettling = false;\n    // Whether enemy is in settling/oscillation mode\n    this.currentScore = 0;\n    // Track current score for chaos calculation\n    this.laserSpawnCounter = 0;\n    // New: Counter for alternating laser widths\n    this.enemyGrowthLevel = 0;\n    // How many times the enemy has grown\n    this.centerY = void 0;\n    this.minLaserY = void 0;\n    this.enemyX = void 0;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.targetEnemyY = centerY;\n    this.enemyX = enemyX;\n    this.initializeLasers();\n  }\n\n  /**\n   * Sets the current growth level of the enemy.\n   * This is called from the main game loop when the hit counter threshold is met.\n   * @param level The new growth level.\n   */\n  setEnemyGrowthLevel(level) {\n    this.enemyGrowthLevel = level;\n  }\n\n  /**\n   * Directly sets the score for the physics system.\n   * Useful for test buttons or other external score modifications.\n   */\n  setScore(newScore) {\n    this.currentScore = newScore;\n  }\n\n  /**\n   * Determines the width of the next laser to spawn based on an alternating pattern.\n   * This ensures that one laser is normal width, the next is double width, and so on.\n   * This pattern activates when the score is 100 or more.\n   */\n  getNextLaserWidth() {\n    if (this.currentScore >= 100) {\n      // Apply alternating width from score 100\n      return this.laserSpawnCounter++ % 2 === 0 ? LASER_WIDTH : LASER_WIDTH * 2;\n    }\n    return LASER_WIDTH;\n  }\n\n  /**\n   * Generate a random Y position for laser spawn\n   * Chaos increases every 5 points, resets at each 25-point threshold\n   */\n  generateRandomLaserY(score) {\n    // Calculate position within current 25-point cycle (0-24)\n    const scoreInCycle = score % SCORE_PER_LASER_UNLOCK;\n\n    // Calculate how many 5-point intervals we've passed in this cycle\n    const chaosIntervals = Math.floor(scoreInCycle / CHAOS_INCREMENT_INTERVAL);\n\n    // Calculate current chaos multiplier (resets every 25 points)\n    const currentChaos = BASE_LASER_RANDOMNESS + chaosIntervals * CHAOS_MULTIPLIER_PER_INTERVAL;\n\n    // Calculate the range of valid positions\n    const fullRange = this.centerY - this.minLaserY;\n    const randomRange = fullRange * currentChaos;\n    const centerPosition = this.minLaserY + fullRange / 2;\n\n    // Generate random position within chaos-modified range\n    return centerPosition - randomRange / 2 + Math.random() * randomRange;\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  initializeLasers() {\n    const currentEnemyWidth = BALL_SIZE + this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE;\n    const firstLaserY = this.centerY;\n    const nextLaserY = this.generateRandomLaserY(0);\n    this.lasers = [{\n      x: this.enemyX + currentEnemyWidth / 2,\n      // Spawn from enemy center X\n      y: firstLaserY,\n      hit: false,\n      scored: false,\n      passed: false,\n      nextY: nextLaserY,\n      // Pre-calculate next position\n      width: this.getNextLaserWidth() // Use new method for initial width\n    }];\n\n    // Set initial target\n    this.targetEnemyY = firstLaserY;\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score) {\n    this.currentScore = score; // Update score for chaos calculation\n\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reduce speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      // Special case: Reset total speed to specific value at score 50 (3rd laser)\n      if (this.numLasers === 3) {\n        // Start smooth transition to new speed\n        this.transitionStartSpeed = this.getCurrentSpeed(score);\n        this.transitionTargetSpeed = LASER_SPEED_AT_SCORE_50;\n        this.transitionProgress = 0;\n        this.isTransitioningSpeed = true;\n\n        // Reset baseSpeed and track when we reset\n        this.baseSpeed = LASER_SPEED_AT_SCORE_50;\n        this.speedResetScore = score; // Remember we reset at this score\n      }\n      // Special case: Reset total speed to specific value at score 75 (4th laser)\n      else if (this.numLasers === 4) {\n        // Start smooth transition to new speed\n        this.transitionStartSpeed = this.getCurrentSpeed(score);\n        this.transitionTargetSpeed = LASER_SPEED_AT_SCORE_75;\n        this.transitionProgress = 0;\n        this.isTransitioningSpeed = true;\n\n        // Reset baseSpeed and track when we reset\n        this.baseSpeed = LASER_SPEED_AT_SCORE_75;\n        this.speedResetScore = score; // Remember we reset at this score\n      } else {\n        this.baseSpeed = Math.max(1, this.baseSpeed - LASER_SPEED_REDUCTION_ON_UNLOCK);\n      }\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      const currentEnemyWidth = BALL_SIZE + this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE;\n      const newLaserY = this.generateRandomLaserY(score);\n      // When a new laser is added, ensure its initial width follows the alternating pattern\n      this.lasers.push({\n        x: this.enemyX + currentEnemyWidth / 2,\n        // Spawn from enemy center X\n        y: newLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: this.generateRandomLaserY(score),\n        // Pre-calculate next position\n        width: this.getNextLaserWidth() // Use new method for new lasers\n      });\n    }\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Easing function for smooth transitions (ease-out cubic)\n   */\n  easeOutCubic(t) {\n    return 1 - Math.pow(1 - t, 3);\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   * Level 1 (0-99): Speed increases by LASER_SPEED_INCREMENT every SCORE_PER_SPEED_INCREMENT points\n   * Level 2 (100+): Speed stays constant at the value when entering Level 2\n   * Between scores 25-50, gradual reduction is applied\n   */\n  getCurrentSpeed(score) {\n    let speed;\n\n    // Level 2: Speed is constant (no incremental increases)\n    if (score >= 100) {\n      // If we've reset speed (at score 50 or 75), use that base speed\n      if (this.speedResetScore >= 0 && this.speedResetScore >= 50) {\n        speed = this.baseSpeed; // Just use base speed, no increments\n      } else {\n        // Calculate what the speed was at score 99 and keep it constant\n        const speedIncrements = Math.floor(99 / SCORE_PER_SPEED_INCREMENT);\n        speed = this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n      }\n    }\n    // Level 1: Normal incremental speed\n    else if (this.speedResetScore >= 0 && score > this.speedResetScore) {\n      // Calculate how many increments have happened since the reset\n      const incrementsSinceReset = Math.floor((score - this.speedResetScore) / SCORE_PER_SPEED_INCREMENT);\n      speed = this.baseSpeed + LASER_SPEED_INCREMENT * incrementsSinceReset;\n    } else {\n      // Normal incremental speed calculation before reset\n      const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT);\n      speed = this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n\n      // Apply gradual reduction between scores 25-50\n      if (score > 25 && score < 50) {\n        const pointsPast25 = score - 25;\n        const reduction = pointsPast25 * LASER_SPEED_GRADUAL_REDUCTION;\n        speed -= reduction;\n      }\n    }\n\n    // If transitioning, interpolate between start and target speed\n    if (this.isTransitioningSpeed) {\n      const easedProgress = this.easeOutCubic(this.transitionProgress);\n      speed = this.transitionStartSpeed + (this.transitionTargetSpeed - this.transitionStartSpeed) * easedProgress;\n    }\n    return speed;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change, hit status, and enemy hit count\n   */\n  update(score, playerPosition, playerHasJumped) {\n    this.currentScore = score; // Update score for chaos calculation\n\n    // Update speed transition progress\n    if (this.isTransitioningSpeed) {\n      // Increment progress (assuming ~16.67ms per frame at 60 FPS)\n      this.transitionProgress += 16.67 / LASER_SPEED_TRANSITION_DURATION;\n      if (this.transitionProgress >= 1) {\n        this.transitionProgress = 1;\n        this.isTransitioningSpeed = false; // Transition complete\n      }\n    }\n    const currentSpeed = this.getCurrentSpeed(score);\n    let scoreChange = 0;\n    let wasHit = false;\n    let enemyHitCount = 0; // Track enemy hits on player\n\n    this.lasers.forEach(laser => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      const laserWidth = laser.width || LASER_WIDTH;\n      if (laser.x + laserWidth < 0) {\n        const currentEnemyWidth = BALL_SIZE + this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE;\n        const currentEnemyHeight = BALL_SIZE + this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE;\n        // Spawn laser from enemy's current center position\n        laser.x = this.enemyX + currentEnemyWidth / 2;\n        laser.y = this.enemyY + currentEnemyHeight / 2; // Spawn from enemy's current center Y\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n        // Use the new method for respawned lasers to maintain the alternating pattern\n        laser.width = this.getNextLaserWidth();\n        // Calculate the NEXT spawn position with chaos based on current score\n        laser.nextY = this.generateRandomLaserY(this.currentScore);\n\n        // Set up delayed movement to next position\n        this.pendingTargetY = laser.nextY;\n        this.movementDelayTimer = ENEMY_MOVEMENT_DELAY;\n      }\n\n      // Check collision with player (use laser's custom width if set)\n      const currentLaserWidth = laser.width || LASER_WIDTH;\n      if (!laser.hit && playerPosition.x + BALL_SIZE > laser.x && playerPosition.x < laser.x + currentLaserWidth && playerPosition.y + BALL_SIZE > laser.y &&\n      // Player bottom vs laser top\n      playerPosition.y < laser.y + LASER_HEIGHT // Player top vs laser bottom\n      ) {\n        laser.hit = true;\n        wasHit = true;\n        enemyHitCount++; // Increment enemy hit counter\n\n        // Make laser disappear (respawn) when it hits the player\n        const currentEnemyWidth = BALL_SIZE + this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE;\n        const currentEnemyHeight = BALL_SIZE + this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE;\n        laser.x = this.enemyX + currentEnemyWidth / 2;\n        laser.y = this.enemyY + currentEnemyHeight / 2;\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n        laser.width = this.getNextLaserWidth();\n        laser.nextY = this.generateRandomLaserY(this.currentScore);\n\n        // Set up delayed movement to next position\n        this.pendingTargetY = laser.nextY;\n        this.movementDelayTimer = ENEMY_MOVEMENT_DELAY;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (!laser.scored && !laser.hit && playerHasJumped && playerPosition.x > laser.x + currentLaserWidth) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    // Handle movement delay timer\n    if (this.movementDelayTimer > 0) {\n      // Countdown the delay timer (assuming ~16.67ms per frame at 60 FPS)\n      this.movementDelayTimer -= 16.67;\n\n      // When delay expires, start moving to the pending target\n      if (this.movementDelayTimer <= 0 && this.pendingTargetY !== null) {\n        this.targetEnemyY = this.pendingTargetY;\n        this.pendingTargetY = null;\n        this.isSettling = false; // Reset settling mode for new movement\n      }\n    }\n    const previousY = this.enemyY;\n    const distanceToTarget = Math.abs(this.targetEnemyY - this.enemyY);\n\n    // Check if we should enter settling/oscillation mode\n    if (distanceToTarget < ENEMY_SETTLE_THRESHOLD && !this.isSettling) {\n      this.isSettling = true;\n      // Give it a strong initial bounce velocity for visible overshoot\n      // Direction depends on which way we're approaching\n      const direction = this.enemyY < this.targetEnemyY ? 1 : -1;\n      this.oscillationVelocity = direction * ENEMY_BOUNCE_AMPLITUDE;\n    }\n    if (this.isSettling) {\n      // Physics-based oscillation (like blue ball bouncing)\n      this.enemyY += this.oscillationVelocity;\n\n      // Check if we've crossed the target (bounce)\n      const crossedTarget = this.oscillationVelocity > 0 && this.enemyY > this.targetEnemyY || this.oscillationVelocity < 0 && this.enemyY < this.targetEnemyY;\n      if (crossedTarget) {\n        // Snap to target and reverse with damping\n        this.enemyY = this.targetEnemyY;\n        this.oscillationVelocity = -this.oscillationVelocity * ENEMY_OSCILLATION_DAMPING;\n      }\n\n      // Stop oscillating when velocity is too small\n      if (Math.abs(this.oscillationVelocity) < ENEMY_MIN_OSCILLATION_VELOCITY) {\n        this.oscillationVelocity = 0;\n        this.enemyY = this.targetEnemyY;\n      }\n    } else {\n      // Normal smooth interpolation when not settling\n      this.enemyY += (this.targetEnemyY - this.enemyY) * ENEMY_MOVE_SPEED;\n    }\n\n    // Calculate velocity for squash/stretch effect\n    this.enemyVelocity = this.enemyY - previousY;\n    return {\n      scoreChange,\n      wasHit,\n      enemyHitCount\n    };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers() {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers() {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position (smoothly animated)\n   */\n  getEnemyY() {\n    return this.enemyY;\n  }\n\n  /**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   * Squishes in the direction of movement (like blue ball bouncing through liquid)\n   */\n  getEnemyScale() {\n    // Calculate the base scale factor based on growth level.\n    // Each growth level adds 0.25 to the base scale of 1.\n    // This directly implements the requirement: initial 1 + (growthLevel * 0.25).\n    return 1 + this.enemyGrowthLevel * 0.25;\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset() {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.targetEnemyY = this.centerY;\n    this.laserSpawnCounter = 0; // Reset counter on game restart\n    this.enemyGrowthLevel = 0; // Reset growth on game restart\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth, screenHeight, centerY, enemyX) {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyX = enemyX;\n  }\n}","map":{"version":3,"names":["LASER_WIDTH","LASER_HEIGHT","BASE_LASER_SPEED","LASER_SPEED_INCREMENT","LASER_SPEED_REDUCTION_ON_UNLOCK","LASER_SPEED_GRADUAL_REDUCTION","LASER_SPEED_AT_SCORE_50","LASER_SPEED_AT_SCORE_75","LASER_SPEED_TRANSITION_DURATION","MAX_LASERS","SCORE_PER_LASER_UNLOCK","SCORE_PER_SPEED_INCREMENT","BALL_SIZE","ENEMY_MOVE_SPEED","ENEMY_MOVEMENT_DELAY","ENEMY_SETTLE_THRESHOLD","ENEMY_BOUNCE_AMPLITUDE","ENEMY_OSCILLATION_DAMPING","ENEMY_MIN_OSCILLATION_VELOCITY","CHAOS_INCREMENT_INTERVAL","BASE_LASER_RANDOMNESS","CHAOS_MULTIPLIER_PER_INTERVAL","ENEMY_WIDTH_GROWTH_PER_CYCLE","ENEMY_HEIGHT_GROWTH_PER_CYCLE","LaserPhysics","constructor","screenWidth","screenHeight","centerY","enemyX","lasers","numLasers","baseSpeed","speedResetScore","isTransitioningSpeed","transitionStartSpeed","transitionTargetSpeed","transitionProgress","enemyY","targetEnemyY","pendingTargetY","movementDelayTimer","enemyVelocity","oscillationVelocity","isSettling","currentScore","laserSpawnCounter","enemyGrowthLevel","minLaserY","initializeLasers","setEnemyGrowthLevel","level","setScore","newScore","getNextLaserWidth","generateRandomLaserY","score","scoreInCycle","chaosIntervals","Math","floor","currentChaos","fullRange","randomRange","centerPosition","random","currentEnemyWidth","firstLaserY","nextLaserY","x","y","hit","scored","passed","nextY","width","updateLaserCount","extraLasers","prevNumLasers","min","getCurrentSpeed","max","length","newLaserY","push","pop","easeOutCubic","t","pow","speed","speedIncrements","incrementsSinceReset","pointsPast25","reduction","easedProgress","update","playerPosition","playerHasJumped","currentSpeed","scoreChange","wasHit","enemyHitCount","forEach","laser","laserWidth","currentEnemyHeight","currentLaserWidth","previousY","distanceToTarget","abs","direction","crossedTarget","getLasers","getNumLasers","getEnemyY","getEnemyScale","reset","updateDimensions"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/laserPhysics.ts"],"sourcesContent":["/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */\n\nimport { LaserState, Position } from '../types/game';\nimport {\n  LASER_WIDTH,\n  LASER_HEIGHT,\n  BASE_LASER_SPEED,\n  LASER_SPEED_INCREMENT,\n  LASER_SPEED_REDUCTION_ON_UNLOCK,\n  LASER_SPEED_GRADUAL_REDUCTION,\n  LASER_SPEED_AT_SCORE_50,\n  LASER_SPEED_AT_SCORE_75,\n  LASER_SPEED_TRANSITION_DURATION,\n  MAX_LASERS,\n  SCORE_PER_LASER_UNLOCK,\n  SCORE_PER_SPEED_INCREMENT,\n  SPEED_INCREMENTS_PER_CYCLE,\n  BALL_SIZE,\n  ENEMY_MOVE_SPEED,\n  ENEMY_MOVEMENT_DELAY,\n  ENEMY_SETTLE_THRESHOLD,\n  ENEMY_BOUNCE_AMPLITUDE,\n  ENEMY_OSCILLATION_DAMPING,\n  ENEMY_MIN_OSCILLATION_VELOCITY,\n  CHAOS_INCREMENT_INTERVAL,\n  BASE_LASER_RANDOMNESS,\n  CHAOS_MULTIPLIER_PER_INTERVAL,\n} from '../config/gameConfig';\nimport {\n  ENEMY_WIDTH_GROWTH_PER_CYCLE,\n  ENEMY_HEIGHT_GROWTH_PER_CYCLE,\n} from '../config/gameConfig';\n\nexport class LaserPhysics {\n  private lasers: LaserState[] = [];\n  private numLasers: number = 1;\n  private baseSpeed: number = BASE_LASER_SPEED;\n  private speedResetScore: number = -1; // Track when speed was last reset (for score 50 logic)\n  private isTransitioningSpeed: boolean = false; // Track if speed is currently transitioning\n  private transitionStartSpeed: number = 0; // Speed at start of transition\n  private transitionTargetSpeed: number = 0; // Target speed for transition\n  private transitionProgress: number = 0; // Progress of transition (0 to 1)\n  private enemyY: number;\n  private targetEnemyY: number; // Target Y position for smooth movement\n  private pendingTargetY: number | null = null; // Delayed target position\n  private movementDelayTimer: number = 0; // Timer for movement delay\n  private enemyVelocity: number = 0; // Track movement velocity for squash/stretch\n  private oscillationVelocity: number = 0; // Velocity for settling bounce/oscillation\n  private isSettling: boolean = false; // Whether enemy is in settling/oscillation mode\n  private currentScore: number = 0; // Track current score for chaos calculation\n  private laserSpawnCounter: number = 0; // New: Counter for alternating laser widths\n  private enemyGrowthLevel: number = 0; // How many times the enemy has grown\n  private centerY: number;\n  private minLaserY: number;\n  private enemyX: number;\n\n  constructor(screenWidth: number, screenHeight: number, centerY: number, enemyX: number) {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.targetEnemyY = centerY;\n    this.enemyX = enemyX;\n    this.initializeLasers();\n  }\n\n  /**\n   * Sets the current growth level of the enemy.\n   * This is called from the main game loop when the hit counter threshold is met.\n   * @param level The new growth level.\n   */\n  setEnemyGrowthLevel(level: number): void {\n    this.enemyGrowthLevel = level;\n  }\n\n  /**\n   * Directly sets the score for the physics system.\n   * Useful for test buttons or other external score modifications.\n   */\n  setScore(newScore: number): void {\n    this.currentScore = newScore;\n  }\n\n  /**\n   * Determines the width of the next laser to spawn based on an alternating pattern.\n   * This ensures that one laser is normal width, the next is double width, and so on.\n   * This pattern activates when the score is 100 or more.\n   */\n  private getNextLaserWidth(): number {\n    if (this.currentScore >= 100) { // Apply alternating width from score 100\n      return (this.laserSpawnCounter++ % 2 === 0) ? LASER_WIDTH : LASER_WIDTH * 2;\n    }\n    return LASER_WIDTH;\n  }\n\n  /**\n   * Generate a random Y position for laser spawn\n   * Chaos increases every 5 points, resets at each 25-point threshold\n   */\n  private generateRandomLaserY(score: number): number {\n    // Calculate position within current 25-point cycle (0-24)\n    const scoreInCycle = score % SCORE_PER_LASER_UNLOCK;\n\n    // Calculate how many 5-point intervals we've passed in this cycle\n    const chaosIntervals = Math.floor(scoreInCycle / CHAOS_INCREMENT_INTERVAL);\n\n    // Calculate current chaos multiplier (resets every 25 points)\n    const currentChaos = BASE_LASER_RANDOMNESS + (chaosIntervals * CHAOS_MULTIPLIER_PER_INTERVAL);\n\n    // Calculate the range of valid positions\n    const fullRange = this.centerY - this.minLaserY;\n    const randomRange = fullRange * currentChaos;\n    const centerPosition = this.minLaserY + (fullRange / 2);\n\n    // Generate random position within chaos-modified range\n    return centerPosition - (randomRange / 2) + (Math.random() * randomRange);\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  private initializeLasers(): void {\n    const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n    const firstLaserY = this.centerY;\n    const nextLaserY = this.generateRandomLaserY(0);\n\n    this.lasers = [\n      {\n        x: this.enemyX + currentEnemyWidth / 2, // Spawn from enemy center X\n        y: firstLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: nextLaserY, // Pre-calculate next position\n        width: this.getNextLaserWidth(), // Use new method for initial width\n      },\n    ];\n\n    // Set initial target\n    this.targetEnemyY = firstLaserY;\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score: number): void {\n    this.currentScore = score; // Update score for chaos calculation\n\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reduce speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      // Special case: Reset total speed to specific value at score 50 (3rd laser)\n      if (this.numLasers === 3) {\n        // Start smooth transition to new speed\n        this.transitionStartSpeed = this.getCurrentSpeed(score);\n        this.transitionTargetSpeed = LASER_SPEED_AT_SCORE_50;\n        this.transitionProgress = 0;\n        this.isTransitioningSpeed = true;\n\n        // Reset baseSpeed and track when we reset\n        this.baseSpeed = LASER_SPEED_AT_SCORE_50;\n        this.speedResetScore = score; // Remember we reset at this score\n      }\n      // Special case: Reset total speed to specific value at score 75 (4th laser)\n      else if (this.numLasers === 4) {\n        // Start smooth transition to new speed\n        this.transitionStartSpeed = this.getCurrentSpeed(score);\n        this.transitionTargetSpeed = LASER_SPEED_AT_SCORE_75;\n        this.transitionProgress = 0;\n        this.isTransitioningSpeed = true;\n\n        // Reset baseSpeed and track when we reset\n        this.baseSpeed = LASER_SPEED_AT_SCORE_75;\n        this.speedResetScore = score; // Remember we reset at this score\n      }\n      else {\n        this.baseSpeed = Math.max(1, this.baseSpeed - LASER_SPEED_REDUCTION_ON_UNLOCK);\n      }\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n      const newLaserY = this.generateRandomLaserY(score);\n      // When a new laser is added, ensure its initial width follows the alternating pattern\n      this.lasers.push({\n        x: this.enemyX + currentEnemyWidth / 2, // Spawn from enemy center X\n        y: newLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: this.generateRandomLaserY(score), // Pre-calculate next position\n        width: this.getNextLaserWidth(), // Use new method for new lasers\n      });\n    }\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Easing function for smooth transitions (ease-out cubic)\n   */\n  private easeOutCubic(t: number): number {\n    return 1 - Math.pow(1 - t, 3);\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   * Level 1 (0-99): Speed increases by LASER_SPEED_INCREMENT every SCORE_PER_SPEED_INCREMENT points\n   * Level 2 (100+): Speed stays constant at the value when entering Level 2\n   * Between scores 25-50, gradual reduction is applied\n   */\n  private getCurrentSpeed(score: number): number {\n    let speed: number;\n\n    // Level 2: Speed is constant (no incremental increases)\n    if (score >= 100) {\n      // If we've reset speed (at score 50 or 75), use that base speed\n      if (this.speedResetScore >= 0 && this.speedResetScore >= 50) {\n        speed = this.baseSpeed; // Just use base speed, no increments\n      } else {\n        // Calculate what the speed was at score 99 and keep it constant\n        const speedIncrements = Math.floor(99 / SCORE_PER_SPEED_INCREMENT);\n        speed = this.baseSpeed + (LASER_SPEED_INCREMENT * speedIncrements);\n      }\n    }\n    // Level 1: Normal incremental speed\n    else if (this.speedResetScore >= 0 && score > this.speedResetScore) {\n      // Calculate how many increments have happened since the reset\n      const incrementsSinceReset = Math.floor((score - this.speedResetScore) / SCORE_PER_SPEED_INCREMENT);\n      speed = this.baseSpeed + (LASER_SPEED_INCREMENT * incrementsSinceReset);\n    } else {\n      // Normal incremental speed calculation before reset\n      const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT);\n      speed = this.baseSpeed + (LASER_SPEED_INCREMENT * speedIncrements);\n\n      // Apply gradual reduction between scores 25-50\n      if (score > 25 && score < 50) {\n        const pointsPast25 = score - 25;\n        const reduction = pointsPast25 * LASER_SPEED_GRADUAL_REDUCTION;\n        speed -= reduction;\n      }\n    }\n\n    // If transitioning, interpolate between start and target speed\n    if (this.isTransitioningSpeed) {\n      const easedProgress = this.easeOutCubic(this.transitionProgress);\n      speed = this.transitionStartSpeed + (this.transitionTargetSpeed - this.transitionStartSpeed) * easedProgress;\n    }\n\n    return speed;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change, hit status, and enemy hit count\n   */\n  update(\n    score: number,\n    playerPosition: Position,\n    playerHasJumped: boolean\n  ): { scoreChange: number; wasHit: boolean; enemyHitCount: number } {\n    this.currentScore = score; // Update score for chaos calculation\n\n    // Update speed transition progress\n    if (this.isTransitioningSpeed) {\n      // Increment progress (assuming ~16.67ms per frame at 60 FPS)\n      this.transitionProgress += 16.67 / LASER_SPEED_TRANSITION_DURATION;\n      if (this.transitionProgress >= 1) {\n        this.transitionProgress = 1;\n        this.isTransitioningSpeed = false; // Transition complete\n      }\n    }\n\n    const currentSpeed = this.getCurrentSpeed(score);\n    let scoreChange = 0;\n    let wasHit = false;\n    let enemyHitCount = 0; // Track enemy hits on player\n\n    this.lasers.forEach((laser) => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      const laserWidth = laser.width || LASER_WIDTH;\n      if (laser.x + laserWidth < 0) {\n        const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n        const currentEnemyHeight = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE);\n        // Spawn laser from enemy's current center position\n        laser.x = this.enemyX + currentEnemyWidth / 2;\n        laser.y = this.enemyY + currentEnemyHeight / 2; // Spawn from enemy's current center Y\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n        // Use the new method for respawned lasers to maintain the alternating pattern\n        laser.width = this.getNextLaserWidth();\n        // Calculate the NEXT spawn position with chaos based on current score\n        laser.nextY = this.generateRandomLaserY(this.currentScore);\n\n        // Set up delayed movement to next position\n        this.pendingTargetY = laser.nextY;\n        this.movementDelayTimer = ENEMY_MOVEMENT_DELAY;\n      }\n\n      // Check collision with player (use laser's custom width if set)\n      const currentLaserWidth = laser.width || LASER_WIDTH;\n      if (\n        !laser.hit &&\n        playerPosition.x + BALL_SIZE > laser.x &&\n        playerPosition.x < laser.x + currentLaserWidth &&\n        playerPosition.y + BALL_SIZE > laser.y && // Player bottom vs laser top\n        playerPosition.y < laser.y + LASER_HEIGHT // Player top vs laser bottom\n      ) {\n        laser.hit = true;\n        wasHit = true;\n        enemyHitCount++; // Increment enemy hit counter\n\n        // Make laser disappear (respawn) when it hits the player\n        const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n        const currentEnemyHeight = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE);\n        laser.x = this.enemyX + currentEnemyWidth / 2;\n        laser.y = this.enemyY + currentEnemyHeight / 2;\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n        laser.width = this.getNextLaserWidth();\n        laser.nextY = this.generateRandomLaserY(this.currentScore);\n\n        // Set up delayed movement to next position\n        this.pendingTargetY = laser.nextY;\n        this.movementDelayTimer = ENEMY_MOVEMENT_DELAY;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (\n        !laser.scored &&\n        !laser.hit &&\n        playerHasJumped &&\n        playerPosition.x > laser.x + currentLaserWidth\n      ) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    // Handle movement delay timer\n    if (this.movementDelayTimer > 0) {\n      // Countdown the delay timer (assuming ~16.67ms per frame at 60 FPS)\n      this.movementDelayTimer -= 16.67;\n\n      // When delay expires, start moving to the pending target\n      if (this.movementDelayTimer <= 0 && this.pendingTargetY !== null) {\n        this.targetEnemyY = this.pendingTargetY;\n        this.pendingTargetY = null;\n        this.isSettling = false; // Reset settling mode for new movement\n      }\n    }\n\n    const previousY = this.enemyY;\n    const distanceToTarget = Math.abs(this.targetEnemyY - this.enemyY);\n\n    // Check if we should enter settling/oscillation mode\n    if (distanceToTarget < ENEMY_SETTLE_THRESHOLD && !this.isSettling) {\n      this.isSettling = true;\n      // Give it a strong initial bounce velocity for visible overshoot\n      // Direction depends on which way we're approaching\n      const direction = this.enemyY < this.targetEnemyY ? 1 : -1;\n      this.oscillationVelocity = direction * ENEMY_BOUNCE_AMPLITUDE;\n    }\n\n    if (this.isSettling) {\n      // Physics-based oscillation (like blue ball bouncing)\n      this.enemyY += this.oscillationVelocity;\n\n      // Check if we've crossed the target (bounce)\n      const crossedTarget =\n        (this.oscillationVelocity > 0 && this.enemyY > this.targetEnemyY) ||\n        (this.oscillationVelocity < 0 && this.enemyY < this.targetEnemyY);\n\n      if (crossedTarget) {\n        // Snap to target and reverse with damping\n        this.enemyY = this.targetEnemyY;\n        this.oscillationVelocity = -this.oscillationVelocity * ENEMY_OSCILLATION_DAMPING;\n      }\n\n      // Stop oscillating when velocity is too small\n      if (Math.abs(this.oscillationVelocity) < ENEMY_MIN_OSCILLATION_VELOCITY) {\n        this.oscillationVelocity = 0;\n        this.enemyY = this.targetEnemyY;\n      }\n    } else {\n      // Normal smooth interpolation when not settling\n      this.enemyY += (this.targetEnemyY - this.enemyY) * ENEMY_MOVE_SPEED;\n    }\n\n    // Calculate velocity for squash/stretch effect\n    this.enemyVelocity = this.enemyY - previousY;\n\n    return { scoreChange, wasHit, enemyHitCount };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers(): LaserState[] {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers(): number {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position (smoothly animated)\n   */\n  getEnemyY(): number {\n    return this.enemyY;\n  }\n\n  /**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   * Squishes in the direction of movement (like blue ball bouncing through liquid)\n   */\n  getEnemyScale(): number {\n    // Calculate the base scale factor based on growth level.\n    // Each growth level adds 0.25 to the base scale of 1.\n    // This directly implements the requirement: initial 1 + (growthLevel * 0.25).\n    return 1 + (this.enemyGrowthLevel * 0.25);\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset(): void {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.targetEnemyY = this.centerY;\n    this.laserSpawnCounter = 0; // Reset counter on game restart\n    this.enemyGrowthLevel = 0; // Reset growth on game restart\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth: number, screenHeight: number, centerY: number, enemyX: number): void {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyX = enemyX;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}