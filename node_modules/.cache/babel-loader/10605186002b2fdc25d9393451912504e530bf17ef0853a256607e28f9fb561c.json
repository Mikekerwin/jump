{"ast":null,"code":"/**\n * Player Physics System\n * Handles player movement, gravity, jumping, and bouncing\n */import{GRAVITY,ENERGY_LOSS,BOOST,HOLD_BOOST,MAX_HOLD_TIME,MIN_BOUNCE_VELOCITY,PLAYER_HORIZONTAL_RANGE}from'../config/gameConfig';export class PlayerPhysics{// Target X position for mouse movement\nconstructor(initialX,initialY,centerY){this.playerState=void 0;this.centerY=void 0;this.baseX=void 0;// Base X position (center)\nthis.targetX=void 0;this.centerY=centerY;this.baseX=initialX;this.targetX=initialX;this.playerState={position:{x:initialX,y:initialY},velocity:0,scaleX:1,scaleY:1,hasJumped:false,isHolding:false,holdStartTime:0};}/**\n   * Update player physics for one frame\n   */update(){// Smoothly interpolate horizontal position toward target\nthis.playerState.position.x+=(this.targetX-this.playerState.position.x)*0.15;// Apply gravity\nthis.playerState.velocity-=GRAVITY;// Apply hold boost\nif(this.playerState.isHolding){const heldTime=performance.now()-this.playerState.holdStartTime;if(heldTime<MAX_HOLD_TIME){this.playerState.velocity+=HOLD_BOOST;}else{this.playerState.isHolding=false;}}// Update vertical position\nthis.playerState.position.y-=this.playerState.velocity;// Handle floor collision (bounce)\nif(this.playerState.position.y>this.centerY){this.playerState.position.y=this.centerY;this.playerState.velocity=-this.playerState.velocity*ENERGY_LOSS;this.playerState.hasJumped=false;// Stop very small bounces\nif(Math.abs(this.playerState.velocity)<MIN_BOUNCE_VELOCITY){this.playerState.velocity=0;}}// Handle ceiling collision\nif(this.playerState.position.y<0){this.playerState.position.y=0;this.playerState.velocity=-this.playerState.velocity*ENERGY_LOSS;}// Update fluid scaling based on velocity and position\nthis.updateScaling();return this.playerState;}/**\n   * Set horizontal position based on mouse/trackpad movement\n   * @param mouseX - Mouse X position relative to screen\n   * @param screenWidth - Width of the game screen\n   */setMousePosition(mouseX,screenWidth){// Convert mouse position to offset from center (-1 to 1)\nconst centerX=screenWidth/2;const offsetFromCenter=(mouseX-centerX)/(screenWidth/2);// Clamp offset to -1 to 1 range\nconst clampedOffset=Math.max(-1,Math.min(1,offsetFromCenter));// Calculate target X within the allowed range\nthis.targetX=this.baseX+clampedOffset*PLAYER_HORIZONTAL_RANGE;}/**\n   * Start a jump (initial press)\n   */startJump(){if(!this.playerState.hasJumped){this.playerState.velocity=BOOST;this.playerState.hasJumped=true;}this.playerState.isHolding=true;this.playerState.holdStartTime=performance.now();}/**\n   * Stop holding jump\n   */endJump(){this.playerState.isHolding=false;}/**\n   * Update player scaling for squash and stretch effect\n   */updateScaling(){let targetScaleX=1;let targetScaleY=1;if(Math.abs(this.playerState.velocity)>0.1){if(this.playerState.velocity>0){// Moving up - stretch vertically\ntargetScaleY=1-this.playerState.velocity/50;targetScaleX=1+this.playerState.velocity/50;}else{// Moving down - stretch horizontally\ntargetScaleY=1+Math.abs(this.playerState.velocity)/50;targetScaleX=1-Math.abs(this.playerState.velocity)/50;}}// Squash when on ground\nif(this.playerState.position.y>=this.centerY&&Math.abs(this.playerState.velocity)<0.5){targetScaleY=0.7;targetScaleX=1.3;}// Return to normal when settled\nif(Math.abs(this.playerState.velocity)<0.01&&this.playerState.position.y>=this.centerY){targetScaleX=1;targetScaleY=1;}// Smooth interpolation\nthis.playerState.scaleX+=(targetScaleX-this.playerState.scaleX)*0.15;this.playerState.scaleY+=(targetScaleY-this.playerState.scaleY)*0.15;}/**\n   * Check if player should trigger a bounce sound\n   */shouldPlayBounceSound(){return this.playerState.position.y>=this.centerY&&Math.abs(this.playerState.velocity)>MIN_BOUNCE_VELOCITY;}/**\n   * Get bounce volume based on velocity\n   */getBounceVolume(){return Math.min(Math.abs(this.playerState.velocity)/BOOST,1);}/**\n   * Reset player to initial state\n   */reset(initialX,initialY){this.playerState={position:{x:initialX,y:initialY},velocity:0,scaleX:1,scaleY:1,hasJumped:false,isHolding:false,holdStartTime:0};}/**\n   * Update center Y (for window resize)\n   */updateCenterY(newCenterY){this.centerY=newCenterY;this.playerState.position.y=newCenterY;}/**\n   * Get current player state\n   */getState(){return this.playerState;}/**\n   * Check if player has jumped (for scoring)\n   */hasPlayerJumped(){return this.playerState.hasJumped;}}","map":{"version":3,"names":["GRAVITY","ENERGY_LOSS","BOOST","HOLD_BOOST","MAX_HOLD_TIME","MIN_BOUNCE_VELOCITY","PLAYER_HORIZONTAL_RANGE","PlayerPhysics","constructor","initialX","initialY","centerY","playerState","baseX","targetX","position","x","y","velocity","scaleX","scaleY","hasJumped","isHolding","holdStartTime","update","heldTime","performance","now","Math","abs","updateScaling","setMousePosition","mouseX","screenWidth","centerX","offsetFromCenter","clampedOffset","max","min","startJump","endJump","targetScaleX","targetScaleY","shouldPlayBounceSound","getBounceVolume","reset","updateCenterY","newCenterY","getState","hasPlayerJumped"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/playerPhysics.ts"],"sourcesContent":["/**\n * Player Physics System\n * Handles player movement, gravity, jumping, and bouncing\n */\n\nimport { PlayerState } from '../types/game';\nimport {\n  GRAVITY,\n  ENERGY_LOSS,\n  BOOST,\n  HOLD_BOOST,\n  MAX_HOLD_TIME,\n  MIN_BOUNCE_VELOCITY,\n  PLAYER_HORIZONTAL_RANGE,\n} from '../config/gameConfig';\n\nexport class PlayerPhysics {\n  private playerState: PlayerState;\n  private centerY: number;\n  private baseX: number; // Base X position (center)\n  private targetX: number; // Target X position for mouse movement\n\n  constructor(initialX: number, initialY: number, centerY: number) {\n    this.centerY = centerY;\n    this.baseX = initialX;\n    this.targetX = initialX;\n    this.playerState = {\n      position: { x: initialX, y: initialY },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0,\n    };\n  }\n\n  /**\n   * Update player physics for one frame\n   */\n  update(): PlayerState {\n    // Smoothly interpolate horizontal position toward target\n    this.playerState.position.x += (this.targetX - this.playerState.position.x) * 0.15;\n\n    // Apply gravity\n    this.playerState.velocity -= GRAVITY;\n\n    // Apply hold boost\n    if (this.playerState.isHolding) {\n      const heldTime = performance.now() - this.playerState.holdStartTime;\n      if (heldTime < MAX_HOLD_TIME) {\n        this.playerState.velocity += HOLD_BOOST;\n      } else {\n        this.playerState.isHolding = false;\n      }\n    }\n\n    // Update vertical position\n    this.playerState.position.y -= this.playerState.velocity;\n\n    // Handle floor collision (bounce)\n    if (this.playerState.position.y > this.centerY) {\n      this.playerState.position.y = this.centerY;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n      this.playerState.hasJumped = false;\n\n      // Stop very small bounces\n      if (Math.abs(this.playerState.velocity) < MIN_BOUNCE_VELOCITY) {\n        this.playerState.velocity = 0;\n      }\n    }\n\n    // Handle ceiling collision\n    if (this.playerState.position.y < 0) {\n      this.playerState.position.y = 0;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n    }\n\n    // Update fluid scaling based on velocity and position\n    this.updateScaling();\n\n    return this.playerState;\n  }\n\n  /**\n   * Set horizontal position based on mouse/trackpad movement\n   * @param mouseX - Mouse X position relative to screen\n   * @param screenWidth - Width of the game screen\n   */\n  setMousePosition(mouseX: number, screenWidth: number): void {\n    // Convert mouse position to offset from center (-1 to 1)\n    const centerX = screenWidth / 2;\n    const offsetFromCenter = (mouseX - centerX) / (screenWidth / 2);\n\n    // Clamp offset to -1 to 1 range\n    const clampedOffset = Math.max(-1, Math.min(1, offsetFromCenter));\n\n    // Calculate target X within the allowed range\n    this.targetX = this.baseX + (clampedOffset * PLAYER_HORIZONTAL_RANGE);\n  }\n\n  /**\n   * Start a jump (initial press)\n   */\n  startJump(): void {\n    if (!this.playerState.hasJumped) {\n      this.playerState.velocity = BOOST;\n      this.playerState.hasJumped = true;\n    }\n    this.playerState.isHolding = true;\n    this.playerState.holdStartTime = performance.now();\n  }\n\n  /**\n   * Stop holding jump\n   */\n  endJump(): void {\n    this.playerState.isHolding = false;\n  }\n\n  /**\n   * Update player scaling for squash and stretch effect\n   */\n  private updateScaling(): void {\n    let targetScaleX = 1;\n    let targetScaleY = 1;\n\n    if (Math.abs(this.playerState.velocity) > 0.1) {\n      if (this.playerState.velocity > 0) {\n        // Moving up - stretch vertically\n        targetScaleY = 1 - this.playerState.velocity / 50;\n        targetScaleX = 1 + this.playerState.velocity / 50;\n      } else {\n        // Moving down - stretch horizontally\n        targetScaleY = 1 + Math.abs(this.playerState.velocity) / 50;\n        targetScaleX = 1 - Math.abs(this.playerState.velocity) / 50;\n      }\n    }\n\n    // Squash when on ground\n    if (\n      this.playerState.position.y >= this.centerY &&\n      Math.abs(this.playerState.velocity) < 0.5\n    ) {\n      targetScaleY = 0.7;\n      targetScaleX = 1.3;\n    }\n\n    // Return to normal when settled\n    if (\n      Math.abs(this.playerState.velocity) < 0.01 &&\n      this.playerState.position.y >= this.centerY\n    ) {\n      targetScaleX = 1;\n      targetScaleY = 1;\n    }\n\n    // Smooth interpolation\n    this.playerState.scaleX += (targetScaleX - this.playerState.scaleX) * 0.15;\n    this.playerState.scaleY += (targetScaleY - this.playerState.scaleY) * 0.15;\n  }\n\n  /**\n   * Check if player should trigger a bounce sound\n   */\n  shouldPlayBounceSound(): boolean {\n    return (\n      this.playerState.position.y >= this.centerY &&\n      Math.abs(this.playerState.velocity) > MIN_BOUNCE_VELOCITY\n    );\n  }\n\n  /**\n   * Get bounce volume based on velocity\n   */\n  getBounceVolume(): number {\n    return Math.min(Math.abs(this.playerState.velocity) / BOOST, 1);\n  }\n\n  /**\n   * Reset player to initial state\n   */\n  reset(initialX: number, initialY: number): void {\n    this.playerState = {\n      position: { x: initialX, y: initialY },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0,\n    };\n  }\n\n  /**\n   * Update center Y (for window resize)\n   */\n  updateCenterY(newCenterY: number): void {\n    this.centerY = newCenterY;\n    this.playerState.position.y = newCenterY;\n  }\n\n  /**\n   * Get current player state\n   */\n  getState(): PlayerState {\n    return this.playerState;\n  }\n\n  /**\n   * Check if player has jumped (for scoring)\n   */\n  hasPlayerJumped(): boolean {\n    return this.playerState.hasJumped;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}