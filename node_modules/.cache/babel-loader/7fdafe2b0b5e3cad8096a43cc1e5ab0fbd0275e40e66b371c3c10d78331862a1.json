{"ast":null,"code":"/**\n * Player Physics System\n * Handles player movement, gravity, jumping, and bouncing\n */\n\nimport { GRAVITY, ENERGY_LOSS, BOOST, HOLD_BOOST, MAX_HOLD_TIME, MIN_BOUNCE_VELOCITY, PLAYER_HORIZONTAL_RANGE } from '../config/gameConfig';\nexport class PlayerPhysics {\n  // Target X position for mouse movement\n\n  constructor(initialX, initialY, centerY) {\n    this.playerState = void 0;\n    this.centerY = void 0;\n    this.baseX = void 0;\n    // Base X position (center)\n    this.targetX = void 0;\n    this.centerY = centerY;\n    this.baseX = initialX;\n    this.targetX = initialX;\n    this.playerState = {\n      position: {\n        x: initialX,\n        y: initialY\n      },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0\n    };\n  }\n\n  /**\n   * Update player physics for one frame\n   */\n  update() {\n    // Smoothly interpolate horizontal position toward target\n    this.playerState.position.x += (this.targetX - this.playerState.position.x) * 0.15;\n\n    // Apply gravity\n    this.playerState.velocity -= GRAVITY;\n\n    // Apply hold boost\n    if (this.playerState.isHolding) {\n      const heldTime = performance.now() - this.playerState.holdStartTime;\n      if (heldTime < MAX_HOLD_TIME) {\n        this.playerState.velocity += HOLD_BOOST;\n      } else {\n        this.playerState.isHolding = false;\n      }\n    }\n\n    // Update vertical position\n    this.playerState.position.y -= this.playerState.velocity;\n\n    // Handle floor collision (bounce)\n    if (this.playerState.position.y > this.centerY) {\n      this.playerState.position.y = this.centerY;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n      this.playerState.hasJumped = false;\n\n      // Stop very small bounces\n      if (Math.abs(this.playerState.velocity) < MIN_BOUNCE_VELOCITY) {\n        this.playerState.velocity = 0;\n      }\n    }\n\n    // Handle ceiling collision\n    if (this.playerState.position.y < 0) {\n      this.playerState.position.y = 0;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n    }\n\n    // Update fluid scaling based on velocity and position\n    this.updateScaling();\n    return this.playerState;\n  }\n\n  /**\n   * Set horizontal position based on mouse/trackpad movement\n   * @param mouseX - Mouse X position relative to screen\n   * @param screenWidth - Width of the game screen\n   */\n  setMousePosition(mouseX, screenWidth) {\n    // Convert mouse position to offset from center (-1 to 1)\n    const centerX = screenWidth / 2;\n    const offsetFromCenter = (mouseX - centerX) / (screenWidth / 2);\n\n    // Clamp offset to -1 to 1 range\n    const clampedOffset = Math.max(-1, Math.min(1, offsetFromCenter));\n\n    // Calculate target X within the allowed range\n    this.targetX = this.baseX + clampedOffset * PLAYER_HORIZONTAL_RANGE;\n  }\n\n  /**\n   * Start a jump (initial press)\n   */\n  startJump() {\n    if (!this.playerState.hasJumped) {\n      this.playerState.velocity = BOOST;\n      this.playerState.hasJumped = true;\n    }\n    this.playerState.isHolding = true;\n    this.playerState.holdStartTime = performance.now();\n  }\n\n  /**\n   * Stop holding jump\n   */\n  endJump() {\n    this.playerState.isHolding = false;\n  }\n\n  /**\n   * Update player scaling for squash and stretch effect\n   */\n  updateScaling() {\n    let targetScaleX = 1;\n    let targetScaleY = 1;\n    if (Math.abs(this.playerState.velocity) > 0.1) {\n      if (this.playerState.velocity > 0) {\n        // Moving up - stretch vertically\n        targetScaleY = 1 - this.playerState.velocity / 50;\n        targetScaleX = 1 + this.playerState.velocity / 50;\n      } else {\n        // Moving down - stretch horizontally\n        targetScaleY = 1 + Math.abs(this.playerState.velocity) / 50;\n        targetScaleX = 1 - Math.abs(this.playerState.velocity) / 50;\n      }\n    }\n\n    // Squash when on ground\n    if (this.playerState.position.y >= this.centerY && Math.abs(this.playerState.velocity) < 0.5) {\n      targetScaleY = 0.7;\n      targetScaleX = 1.3;\n    }\n\n    // Return to normal when settled\n    if (Math.abs(this.playerState.velocity) < 0.01 && this.playerState.position.y >= this.centerY) {\n      targetScaleX = 1;\n      targetScaleY = 1;\n    }\n\n    // Smooth interpolation\n    this.playerState.scaleX += (targetScaleX - this.playerState.scaleX) * 0.15;\n    this.playerState.scaleY += (targetScaleY - this.playerState.scaleY) * 0.15;\n  }\n\n  /**\n   * Check if player should trigger a bounce sound\n   */\n  shouldPlayBounceSound() {\n    return this.playerState.position.y >= this.centerY && Math.abs(this.playerState.velocity) > MIN_BOUNCE_VELOCITY;\n  }\n\n  /**\n   * Get bounce volume based on velocity\n   */\n  getBounceVolume() {\n    return Math.min(Math.abs(this.playerState.velocity) / BOOST, 1);\n  }\n\n  /**\n   * Reset player to initial state\n   */\n  reset(initialX, initialY) {\n    this.playerState = {\n      position: {\n        x: initialX,\n        y: initialY\n      },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0\n    };\n  }\n\n  /**\n   * Update center Y (for window resize)\n   */\n  updateCenterY(newCenterY) {\n    this.centerY = newCenterY;\n    this.playerState.position.y = newCenterY;\n  }\n\n  /**\n   * Get current player state\n   */\n  getState() {\n    return this.playerState;\n  }\n\n  /**\n   * Check if player has jumped (for scoring)\n   */\n  hasPlayerJumped() {\n    return this.playerState.hasJumped;\n  }\n}","map":{"version":3,"names":["GRAVITY","ENERGY_LOSS","BOOST","HOLD_BOOST","MAX_HOLD_TIME","MIN_BOUNCE_VELOCITY","PLAYER_HORIZONTAL_RANGE","PlayerPhysics","constructor","initialX","initialY","centerY","playerState","baseX","targetX","position","x","y","velocity","scaleX","scaleY","hasJumped","isHolding","holdStartTime","update","heldTime","performance","now","Math","abs","updateScaling","setMousePosition","mouseX","screenWidth","centerX","offsetFromCenter","clampedOffset","max","min","startJump","endJump","targetScaleX","targetScaleY","shouldPlayBounceSound","getBounceVolume","reset","updateCenterY","newCenterY","getState","hasPlayerJumped"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/playerPhysics.ts"],"sourcesContent":["/**\n * Player Physics System\n * Handles player movement, gravity, jumping, and bouncing\n */\n\nimport { PlayerState } from '../types/game';\nimport {\n  GRAVITY,\n  ENERGY_LOSS,\n  BOOST,\n  HOLD_BOOST,\n  MAX_HOLD_TIME,\n  MIN_BOUNCE_VELOCITY,\n  PLAYER_HORIZONTAL_RANGE,\n} from '../config/gameConfig';\n\nexport class PlayerPhysics {\n  private playerState: PlayerState;\n  private centerY: number;\n  private baseX: number; // Base X position (center)\n  private targetX: number; // Target X position for mouse movement\n\n  constructor(initialX: number, initialY: number, centerY: number) {\n    this.centerY = centerY;\n    this.baseX = initialX;\n    this.targetX = initialX;\n    this.playerState = {\n      position: { x: initialX, y: initialY },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0,\n    };\n  }\n\n  /**\n   * Update player physics for one frame\n   */\n  update(): PlayerState {\n    // Smoothly interpolate horizontal position toward target\n    this.playerState.position.x += (this.targetX - this.playerState.position.x) * 0.15;\n\n    // Apply gravity\n    this.playerState.velocity -= GRAVITY;\n\n    // Apply hold boost\n    if (this.playerState.isHolding) {\n      const heldTime = performance.now() - this.playerState.holdStartTime;\n      if (heldTime < MAX_HOLD_TIME) {\n        this.playerState.velocity += HOLD_BOOST;\n      } else {\n        this.playerState.isHolding = false;\n      }\n    }\n\n    // Update vertical position\n    this.playerState.position.y -= this.playerState.velocity;\n\n    // Handle floor collision (bounce)\n    if (this.playerState.position.y > this.centerY) {\n      this.playerState.position.y = this.centerY;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n      this.playerState.hasJumped = false;\n\n      // Stop very small bounces\n      if (Math.abs(this.playerState.velocity) < MIN_BOUNCE_VELOCITY) {\n        this.playerState.velocity = 0;\n      }\n    }\n\n    // Handle ceiling collision\n    if (this.playerState.position.y < 0) {\n      this.playerState.position.y = 0;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n    }\n\n    // Update fluid scaling based on velocity and position\n    this.updateScaling();\n\n    return this.playerState;\n  }\n\n  /**\n   * Set horizontal position based on mouse/trackpad movement\n   * @param mouseX - Mouse X position relative to screen\n   * @param screenWidth - Width of the game screen\n   */\n  setMousePosition(mouseX: number, screenWidth: number): void {\n    // Convert mouse position to offset from center (-1 to 1)\n    const centerX = screenWidth / 2;\n    const offsetFromCenter = (mouseX - centerX) / (screenWidth / 2);\n\n    // Clamp offset to -1 to 1 range\n    const clampedOffset = Math.max(-1, Math.min(1, offsetFromCenter));\n\n    // Calculate target X within the allowed range\n    this.targetX = this.baseX + (clampedOffset * PLAYER_HORIZONTAL_RANGE);\n  }\n\n  /**\n   * Start a jump (initial press)\n   */\n  startJump(): void {\n    if (!this.playerState.hasJumped) {\n      this.playerState.velocity = BOOST;\n      this.playerState.hasJumped = true;\n    }\n    this.playerState.isHolding = true;\n    this.playerState.holdStartTime = performance.now();\n  }\n\n  /**\n   * Stop holding jump\n   */\n  endJump(): void {\n    this.playerState.isHolding = false;\n  }\n\n  /**\n   * Update player scaling for squash and stretch effect\n   */\n  private updateScaling(): void {\n    let targetScaleX = 1;\n    let targetScaleY = 1;\n\n    if (Math.abs(this.playerState.velocity) > 0.1) {\n      if (this.playerState.velocity > 0) {\n        // Moving up - stretch vertically\n        targetScaleY = 1 - this.playerState.velocity / 50;\n        targetScaleX = 1 + this.playerState.velocity / 50;\n      } else {\n        // Moving down - stretch horizontally\n        targetScaleY = 1 + Math.abs(this.playerState.velocity) / 50;\n        targetScaleX = 1 - Math.abs(this.playerState.velocity) / 50;\n      }\n    }\n\n    // Squash when on ground\n    if (\n      this.playerState.position.y >= this.centerY &&\n      Math.abs(this.playerState.velocity) < 0.5\n    ) {\n      targetScaleY = 0.7;\n      targetScaleX = 1.3;\n    }\n\n    // Return to normal when settled\n    if (\n      Math.abs(this.playerState.velocity) < 0.01 &&\n      this.playerState.position.y >= this.centerY\n    ) {\n      targetScaleX = 1;\n      targetScaleY = 1;\n    }\n\n    // Smooth interpolation\n    this.playerState.scaleX += (targetScaleX - this.playerState.scaleX) * 0.15;\n    this.playerState.scaleY += (targetScaleY - this.playerState.scaleY) * 0.15;\n  }\n\n  /**\n   * Check if player should trigger a bounce sound\n   */\n  shouldPlayBounceSound(): boolean {\n    return (\n      this.playerState.position.y >= this.centerY &&\n      Math.abs(this.playerState.velocity) > MIN_BOUNCE_VELOCITY\n    );\n  }\n\n  /**\n   * Get bounce volume based on velocity\n   */\n  getBounceVolume(): number {\n    return Math.min(Math.abs(this.playerState.velocity) / BOOST, 1);\n  }\n\n  /**\n   * Reset player to initial state\n   */\n  reset(initialX: number, initialY: number): void {\n    this.playerState = {\n      position: { x: initialX, y: initialY },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0,\n    };\n  }\n\n  /**\n   * Update center Y (for window resize)\n   */\n  updateCenterY(newCenterY: number): void {\n    this.centerY = newCenterY;\n    this.playerState.position.y = newCenterY;\n  }\n\n  /**\n   * Get current player state\n   */\n  getState(): PlayerState {\n    return this.playerState;\n  }\n\n  /**\n   * Check if player has jumped (for scoring)\n   */\n  hasPlayerJumped(): boolean {\n    return this.playerState.hasJumped;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}