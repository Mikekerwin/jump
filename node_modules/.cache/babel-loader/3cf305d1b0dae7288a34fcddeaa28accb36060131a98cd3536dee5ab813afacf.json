{"ast":null,"code":"/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */import{LASER_WIDTH,LASER_HEIGHT,BASE_LASER_SPEED,LASER_SPEED_INCREMENT,LASER_SPEED_REDUCTION_ON_UNLOCK,LASER_SPEED_GRADUAL_REDUCTION,LASER_SPEED_AT_SCORE_50,LASER_SPEED_AT_SCORE_75,LASER_SPEED_TRANSITION_DURATION,MAX_LASERS,SCORE_PER_LASER_UNLOCK,SCORE_PER_SPEED_INCREMENT,BALL_SIZE,ENEMY_MOVE_SPEED,ENEMY_MOVEMENT_DELAY,ENEMY_SETTLE_THRESHOLD,ENEMY_BOUNCE_AMPLITUDE,ENEMY_OSCILLATION_DAMPING,ENEMY_MIN_OSCILLATION_VELOCITY,CHAOS_INCREMENT_INTERVAL,BASE_LASER_RANDOMNESS,CHAOS_MULTIPLIER_PER_INTERVAL}from'../config/gameConfig';import{ENEMY_WIDTH_GROWTH_PER_CYCLE,ENEMY_HEIGHT_GROWTH_PER_CYCLE}from'../config/gameConfig';export class LaserPhysics{constructor(screenWidth,screenHeight,centerY,enemyX){this.lasers=[];this.numLasers=1;this.baseSpeed=BASE_LASER_SPEED;this.speedResetScore=-1;// Track when speed was last reset (for score 50 logic)\nthis.isTransitioningSpeed=false;// Track if speed is currently transitioning\nthis.transitionStartSpeed=0;// Speed at start of transition\nthis.transitionTargetSpeed=0;// Target speed for transition\nthis.transitionProgress=0;// Progress of transition (0 to 1)\nthis.enemyY=void 0;this.targetEnemyY=void 0;// Target Y position for smooth movement\nthis.pendingTargetY=null;// Delayed target position\nthis.movementDelayTimer=0;// Timer for movement delay\nthis.enemyVelocity=0;// Track movement velocity for squash/stretch\nthis.oscillationVelocity=0;// Velocity for settling bounce/oscillation\nthis.isSettling=false;// Whether enemy is in settling/oscillation mode\nthis.currentScore=0;// Track current score for chaos calculation\nthis.laserSpawnCounter=0;// New: Counter for alternating laser widths\nthis.enemyGrowthLevel=0;// How many times the enemy has grown\nthis.centerY=void 0;this.minLaserY=void 0;this.enemyX=void 0;this.centerY=centerY;this.minLaserY=screenHeight*0.5;this.enemyY=centerY;this.targetEnemyY=centerY;this.enemyX=enemyX;this.initializeLasers();}/**\n   * Sets the current growth level of the enemy.\n   * This is called from the main game loop when the hit counter threshold is met.\n   * @param level The new growth level.\n   */setEnemyGrowthLevel(level){this.enemyGrowthLevel=level;}/**\n   * Directly sets the score for the physics system.\n   * Useful for test buttons or other external score modifications.\n   */setScore(newScore){this.currentScore=newScore;}/**\n   * Determines the width of the next laser to spawn based on an alternating pattern.\n   * This ensures that one laser is normal width, the next is double width, and so on.\n   * This pattern activates when the score is 100 or more.\n   */getNextLaserWidth(){if(this.currentScore>=100){// Apply alternating width from score 100\nreturn this.laserSpawnCounter++%2===0?LASER_WIDTH:LASER_WIDTH*2;}return LASER_WIDTH;}/**\n   * Generate a random Y position for laser spawn\n   * Chaos increases every 5 points, resets at each 25-point threshold\n   */generateRandomLaserY(score){// Calculate position within current 25-point cycle (0-24)\nconst scoreInCycle=score%SCORE_PER_LASER_UNLOCK;// Calculate how many 5-point intervals we've passed in this cycle\nconst chaosIntervals=Math.floor(scoreInCycle/CHAOS_INCREMENT_INTERVAL);// Calculate current chaos multiplier (resets every 25 points)\nconst currentChaos=BASE_LASER_RANDOMNESS+chaosIntervals*CHAOS_MULTIPLIER_PER_INTERVAL;// Calculate the range of valid positions\nconst fullRange=this.centerY-this.minLaserY;const randomRange=fullRange*currentChaos;const centerPosition=this.minLaserY+fullRange/2;// Generate random position within chaos-modified range\nreturn centerPosition-randomRange/2+Math.random()*randomRange;}/**\n   * Initialize lasers at starting positions\n   */initializeLasers(){const currentEnemyWidth=BALL_SIZE+this.enemyGrowthLevel*ENEMY_WIDTH_GROWTH_PER_CYCLE;const firstLaserY=this.centerY;const nextLaserY=this.generateRandomLaserY(0);this.lasers=[{x:this.enemyX+currentEnemyWidth/2,// Spawn from enemy center X\ny:firstLaserY,hit:false,scored:false,passed:false,nextY:nextLaserY,// Pre-calculate next position\nwidth:this.getNextLaserWidth()// Use new method for initial width\n}];// Set initial target\nthis.targetEnemyY=firstLaserY;}/**\n   * Update laser count based on score\n   */updateLaserCount(score){this.currentScore=score;// Update score for chaos calculation\nconst extraLasers=Math.floor(score/SCORE_PER_LASER_UNLOCK);const prevNumLasers=this.numLasers;this.numLasers=Math.min(extraLasers+1,MAX_LASERS);// Reduce speed when new laser is added\nif(this.numLasers>prevNumLasers){// Special case: Reset total speed to specific value at score 50 (3rd laser)\nif(this.numLasers===3){// Start smooth transition to new speed\nthis.transitionStartSpeed=this.getCurrentSpeed(score);this.transitionTargetSpeed=LASER_SPEED_AT_SCORE_50;this.transitionProgress=0;this.isTransitioningSpeed=true;// Reset baseSpeed and track when we reset\nthis.baseSpeed=LASER_SPEED_AT_SCORE_50;this.speedResetScore=score;// Remember we reset at this score\n}// Special case: Reset total speed to specific value at score 75 (4th laser)\nelse if(this.numLasers===4){// Start smooth transition to new speed\nthis.transitionStartSpeed=this.getCurrentSpeed(score);this.transitionTargetSpeed=LASER_SPEED_AT_SCORE_75;this.transitionProgress=0;this.isTransitioningSpeed=true;// Reset baseSpeed and track when we reset\nthis.baseSpeed=LASER_SPEED_AT_SCORE_75;this.speedResetScore=score;// Remember we reset at this score\n}else{this.baseSpeed=Math.max(1,this.baseSpeed-LASER_SPEED_REDUCTION_ON_UNLOCK);}}// Adjust laser array\nwhile(this.lasers.length<this.numLasers){const currentEnemyWidth=BALL_SIZE+this.enemyGrowthLevel*ENEMY_WIDTH_GROWTH_PER_CYCLE;const newLaserY=this.generateRandomLaserY(score);// When a new laser is added, ensure its initial width follows the alternating pattern\nthis.lasers.push({x:this.enemyX+currentEnemyWidth/2,// Spawn from enemy center X\ny:newLaserY,hit:false,scored:false,passed:false,nextY:this.generateRandomLaserY(score),// Pre-calculate next position\nwidth:this.getNextLaserWidth()// Use new method for new lasers\n});}while(this.lasers.length>this.numLasers){this.lasers.pop();}}/**\n   * Easing function for smooth transitions (ease-out cubic)\n   */easeOutCubic(t){return 1-Math.pow(1-t,3);}/**\n   * Calculate current laser speed based on score\n   * Level 1 (0-99): Speed increases by LASER_SPEED_INCREMENT every SCORE_PER_SPEED_INCREMENT points\n   * Level 2 (100+): Speed stays constant at the value when entering Level 2\n   * Between scores 25-50, gradual reduction is applied\n   */getCurrentSpeed(score){let speed;// Level 2: Speed is constant (no incremental increases)\nif(score>=100){// If we've reset speed (at score 50 or 75), use that base speed\nif(this.speedResetScore>=0&&this.speedResetScore>=50){speed=this.baseSpeed;// Just use base speed, no increments\n}else{// Calculate what the speed was at score 99 and keep it constant\nconst speedIncrements=Math.floor(99/SCORE_PER_SPEED_INCREMENT);speed=this.baseSpeed+LASER_SPEED_INCREMENT*speedIncrements;}}// Level 1: Normal incremental speed\nelse if(this.speedResetScore>=0&&score>this.speedResetScore){// Calculate how many increments have happened since the reset\nconst incrementsSinceReset=Math.floor((score-this.speedResetScore)/SCORE_PER_SPEED_INCREMENT);speed=this.baseSpeed+LASER_SPEED_INCREMENT*incrementsSinceReset;}else{// Normal incremental speed calculation before reset\nconst speedIncrements=Math.floor(score/SCORE_PER_SPEED_INCREMENT);speed=this.baseSpeed+LASER_SPEED_INCREMENT*speedIncrements;// Apply gradual reduction between scores 25-50\nif(score>25&&score<50){const pointsPast25=score-25;const reduction=pointsPast25*LASER_SPEED_GRADUAL_REDUCTION;speed-=reduction;}}// If transitioning, interpolate between start and target speed\nif(this.isTransitioningSpeed){const easedProgress=this.easeOutCubic(this.transitionProgress);speed=this.transitionStartSpeed+(this.transitionTargetSpeed-this.transitionStartSpeed)*easedProgress;}return speed;}/**\n   * Update all lasers for one frame\n   * Returns score change, hit status, and enemy hit count\n   */update(score,playerPosition,playerHasJumped){this.currentScore=score;// Update score for chaos calculation\n// Update speed transition progress\nif(this.isTransitioningSpeed){// Increment progress (assuming ~16.67ms per frame at 60 FPS)\nthis.transitionProgress+=16.67/LASER_SPEED_TRANSITION_DURATION;if(this.transitionProgress>=1){this.transitionProgress=1;this.isTransitioningSpeed=false;// Transition complete\n}}const currentSpeed=this.getCurrentSpeed(score);let scoreChange=0;let wasHit=false;let enemyHitCount=0;// Track enemy hits on player\nthis.lasers.forEach(laser=>{// Move laser\nlaser.x-=currentSpeed;// Check if player passed without jumping (penalty)\nif(!laser.hit&&!laser.passed&&playerPosition.x>laser.x+LASER_WIDTH){laser.passed=true;if(!playerHasJumped){scoreChange-=1;}}// Respawn laser when off screen\nconst laserWidth=laser.width||LASER_WIDTH;if(laser.x+laserWidth<0){const currentEnemyWidth=BALL_SIZE+this.enemyGrowthLevel*ENEMY_WIDTH_GROWTH_PER_CYCLE;const currentEnemyHeight=BALL_SIZE+this.enemyGrowthLevel*ENEMY_HEIGHT_GROWTH_PER_CYCLE;// Spawn laser from enemy's current center position\nlaser.x=this.enemyX+currentEnemyWidth/2;laser.y=this.enemyY+currentEnemyHeight/2;// Spawn from enemy's current center Y\nlaser.hit=false;laser.scored=false;laser.passed=false;// Use the new method for respawned lasers to maintain the alternating pattern\nlaser.width=this.getNextLaserWidth();// Calculate the NEXT spawn position with chaos based on current score\nlaser.nextY=this.generateRandomLaserY(this.currentScore);// Set up delayed movement to next position\nthis.pendingTargetY=laser.nextY;this.movementDelayTimer=ENEMY_MOVEMENT_DELAY;}// Check collision with player (use laser's custom width if set)\nconst currentLaserWidth=laser.width||LASER_WIDTH;if(!laser.hit&&playerPosition.x+BALL_SIZE>laser.x&&playerPosition.x<laser.x+currentLaserWidth&&playerPosition.y+BALL_SIZE>laser.y&&// Player bottom vs laser top\nplayerPosition.y<laser.y+LASER_HEIGHT// Player top vs laser bottom\n){laser.hit=true;wasHit=true;enemyHitCount++;// Increment enemy hit counter\n// Make laser disappear (respawn) when it hits the player\nconst currentEnemyWidth=BALL_SIZE+this.enemyGrowthLevel*ENEMY_WIDTH_GROWTH_PER_CYCLE;const currentEnemyHeight=BALL_SIZE+this.enemyGrowthLevel*ENEMY_HEIGHT_GROWTH_PER_CYCLE;laser.x=this.enemyX+currentEnemyWidth/2;laser.y=this.enemyY+currentEnemyHeight/2;laser.hit=false;laser.scored=false;laser.passed=false;laser.width=this.getNextLaserWidth();laser.nextY=this.generateRandomLaserY(this.currentScore);// Set up delayed movement to next position\nthis.pendingTargetY=laser.nextY;this.movementDelayTimer=ENEMY_MOVEMENT_DELAY;}// Check if player successfully jumped over laser (scoring)\nif(!laser.scored&&!laser.hit&&playerHasJumped&&playerPosition.x>laser.x+currentLaserWidth){laser.scored=true;scoreChange+=1;}});// Handle movement delay timer\nif(this.movementDelayTimer>0){// Countdown the delay timer (assuming ~16.67ms per frame at 60 FPS)\nthis.movementDelayTimer-=16.67;// When delay expires, start moving to the pending target\nif(this.movementDelayTimer<=0&&this.pendingTargetY!==null){this.targetEnemyY=this.pendingTargetY;this.pendingTargetY=null;this.isSettling=false;// Reset settling mode for new movement\n}}const previousY=this.enemyY;const distanceToTarget=Math.abs(this.targetEnemyY-this.enemyY);// Check if we should enter settling/oscillation mode\nif(distanceToTarget<ENEMY_SETTLE_THRESHOLD&&!this.isSettling){this.isSettling=true;// Give it a strong initial bounce velocity for visible overshoot\n// Direction depends on which way we're approaching\nconst direction=this.enemyY<this.targetEnemyY?1:-1;this.oscillationVelocity=direction*ENEMY_BOUNCE_AMPLITUDE;}if(this.isSettling){// Physics-based oscillation (like blue ball bouncing)\nthis.enemyY+=this.oscillationVelocity;// Check if we've crossed the target (bounce)\nconst crossedTarget=this.oscillationVelocity>0&&this.enemyY>this.targetEnemyY||this.oscillationVelocity<0&&this.enemyY<this.targetEnemyY;if(crossedTarget){// Snap to target and reverse with damping\nthis.enemyY=this.targetEnemyY;this.oscillationVelocity=-this.oscillationVelocity*ENEMY_OSCILLATION_DAMPING;}// Stop oscillating when velocity is too small\nif(Math.abs(this.oscillationVelocity)<ENEMY_MIN_OSCILLATION_VELOCITY){this.oscillationVelocity=0;this.enemyY=this.targetEnemyY;}}else{// Normal smooth interpolation when not settling\nthis.enemyY+=(this.targetEnemyY-this.enemyY)*ENEMY_MOVE_SPEED;}// Calculate velocity for squash/stretch effect\nthis.enemyVelocity=this.enemyY-previousY;return{scoreChange,wasHit,enemyHitCount};}/**\n   * Get all laser states\n   */getLasers(){return this.lasers;}/**\n   * Get current number of active lasers\n   */getNumLasers(){return this.numLasers;}/**\n   * Get enemy Y position (smoothly animated)\n   */getEnemyY(){return this.enemyY;}/**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   * Squishes in the direction of movement (like blue ball bouncing through liquid)\n   */getEnemyScale(){// Calculate the base scale factor based on growth level.\n// Each growth level adds 0.25 to the base scale of 1.\n// This directly implements the requirement: initial 1 + (growthLevel * 0.25).\nreturn 1+this.enemyGrowthLevel*0.25;}/**\n   * Reset laser system\n   */reset(){this.numLasers=1;this.baseSpeed=BASE_LASER_SPEED;this.enemyY=this.centerY;this.targetEnemyY=this.centerY;this.laserSpawnCounter=0;// Reset counter on game restart\nthis.enemyGrowthLevel=0;// Reset growth on game restart\nthis.initializeLasers();}/**\n   * Update dimensions (for window resize)\n   */updateDimensions(screenWidth,screenHeight,centerY,enemyX){this.centerY=centerY;this.minLaserY=screenHeight*0.5;this.enemyX=enemyX;}}","map":{"version":3,"names":["LASER_WIDTH","LASER_HEIGHT","BASE_LASER_SPEED","LASER_SPEED_INCREMENT","LASER_SPEED_REDUCTION_ON_UNLOCK","LASER_SPEED_GRADUAL_REDUCTION","LASER_SPEED_AT_SCORE_50","LASER_SPEED_AT_SCORE_75","LASER_SPEED_TRANSITION_DURATION","MAX_LASERS","SCORE_PER_LASER_UNLOCK","SCORE_PER_SPEED_INCREMENT","BALL_SIZE","ENEMY_MOVE_SPEED","ENEMY_MOVEMENT_DELAY","ENEMY_SETTLE_THRESHOLD","ENEMY_BOUNCE_AMPLITUDE","ENEMY_OSCILLATION_DAMPING","ENEMY_MIN_OSCILLATION_VELOCITY","CHAOS_INCREMENT_INTERVAL","BASE_LASER_RANDOMNESS","CHAOS_MULTIPLIER_PER_INTERVAL","ENEMY_WIDTH_GROWTH_PER_CYCLE","ENEMY_HEIGHT_GROWTH_PER_CYCLE","LaserPhysics","constructor","screenWidth","screenHeight","centerY","enemyX","lasers","numLasers","baseSpeed","speedResetScore","isTransitioningSpeed","transitionStartSpeed","transitionTargetSpeed","transitionProgress","enemyY","targetEnemyY","pendingTargetY","movementDelayTimer","enemyVelocity","oscillationVelocity","isSettling","currentScore","laserSpawnCounter","enemyGrowthLevel","minLaserY","initializeLasers","setEnemyGrowthLevel","level","setScore","newScore","getNextLaserWidth","generateRandomLaserY","score","scoreInCycle","chaosIntervals","Math","floor","currentChaos","fullRange","randomRange","centerPosition","random","currentEnemyWidth","firstLaserY","nextLaserY","x","y","hit","scored","passed","nextY","width","updateLaserCount","extraLasers","prevNumLasers","min","getCurrentSpeed","max","length","newLaserY","push","pop","easeOutCubic","t","pow","speed","speedIncrements","incrementsSinceReset","pointsPast25","reduction","easedProgress","update","playerPosition","playerHasJumped","currentSpeed","scoreChange","wasHit","enemyHitCount","forEach","laser","laserWidth","currentEnemyHeight","currentLaserWidth","previousY","distanceToTarget","abs","direction","crossedTarget","getLasers","getNumLasers","getEnemyY","getEnemyScale","reset","updateDimensions"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/laserPhysics.ts"],"sourcesContent":["/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */\n\nimport { LaserState, Position } from '../types/game';\nimport {\n  LASER_WIDTH,\n  LASER_HEIGHT,\n  BASE_LASER_SPEED,\n  LASER_SPEED_INCREMENT,\n  LASER_SPEED_REDUCTION_ON_UNLOCK,\n  LASER_SPEED_GRADUAL_REDUCTION,\n  LASER_SPEED_AT_SCORE_50,\n  LASER_SPEED_AT_SCORE_75,\n  LASER_SPEED_TRANSITION_DURATION,\n  MAX_LASERS,\n  SCORE_PER_LASER_UNLOCK,\n  SCORE_PER_SPEED_INCREMENT,\n  SPEED_INCREMENTS_PER_CYCLE,\n  BALL_SIZE,\n  ENEMY_MOVE_SPEED,\n  ENEMY_MOVEMENT_DELAY,\n  ENEMY_SETTLE_THRESHOLD,\n  ENEMY_BOUNCE_AMPLITUDE,\n  ENEMY_OSCILLATION_DAMPING,\n  ENEMY_MIN_OSCILLATION_VELOCITY,\n  CHAOS_INCREMENT_INTERVAL,\n  BASE_LASER_RANDOMNESS,\n  CHAOS_MULTIPLIER_PER_INTERVAL,\n} from '../config/gameConfig';\nimport {\n  ENEMY_WIDTH_GROWTH_PER_CYCLE,\n  ENEMY_HEIGHT_GROWTH_PER_CYCLE,\n} from '../config/gameConfig';\n\nexport class LaserPhysics {\n  private lasers: LaserState[] = [];\n  private numLasers: number = 1;\n  private baseSpeed: number = BASE_LASER_SPEED;\n  private speedResetScore: number = -1; // Track when speed was last reset (for score 50 logic)\n  private isTransitioningSpeed: boolean = false; // Track if speed is currently transitioning\n  private transitionStartSpeed: number = 0; // Speed at start of transition\n  private transitionTargetSpeed: number = 0; // Target speed for transition\n  private transitionProgress: number = 0; // Progress of transition (0 to 1)\n  private enemyY: number;\n  private targetEnemyY: number; // Target Y position for smooth movement\n  private pendingTargetY: number | null = null; // Delayed target position\n  private movementDelayTimer: number = 0; // Timer for movement delay\n  private enemyVelocity: number = 0; // Track movement velocity for squash/stretch\n  private oscillationVelocity: number = 0; // Velocity for settling bounce/oscillation\n  private isSettling: boolean = false; // Whether enemy is in settling/oscillation mode\n  private currentScore: number = 0; // Track current score for chaos calculation\n  private laserSpawnCounter: number = 0; // New: Counter for alternating laser widths\n  private enemyGrowthLevel: number = 0; // How many times the enemy has grown\n  private centerY: number;\n  private minLaserY: number;\n  private enemyX: number;\n\n  constructor(screenWidth: number, screenHeight: number, centerY: number, enemyX: number) {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.targetEnemyY = centerY;\n    this.enemyX = enemyX;\n    this.initializeLasers();\n  }\n\n  /**\n   * Sets the current growth level of the enemy.\n   * This is called from the main game loop when the hit counter threshold is met.\n   * @param level The new growth level.\n   */\n  setEnemyGrowthLevel(level: number): void {\n    this.enemyGrowthLevel = level;\n  }\n\n  /**\n   * Directly sets the score for the physics system.\n   * Useful for test buttons or other external score modifications.\n   */\n  setScore(newScore: number): void {\n    this.currentScore = newScore;\n  }\n\n  /**\n   * Determines the width of the next laser to spawn based on an alternating pattern.\n   * This ensures that one laser is normal width, the next is double width, and so on.\n   * This pattern activates when the score is 100 or more.\n   */\n  private getNextLaserWidth(): number {\n    if (this.currentScore >= 100) { // Apply alternating width from score 100\n      return (this.laserSpawnCounter++ % 2 === 0) ? LASER_WIDTH : LASER_WIDTH * 2;\n    }\n    return LASER_WIDTH;\n  }\n\n  /**\n   * Generate a random Y position for laser spawn\n   * Chaos increases every 5 points, resets at each 25-point threshold\n   */\n  private generateRandomLaserY(score: number): number {\n    // Calculate position within current 25-point cycle (0-24)\n    const scoreInCycle = score % SCORE_PER_LASER_UNLOCK;\n\n    // Calculate how many 5-point intervals we've passed in this cycle\n    const chaosIntervals = Math.floor(scoreInCycle / CHAOS_INCREMENT_INTERVAL);\n\n    // Calculate current chaos multiplier (resets every 25 points)\n    const currentChaos = BASE_LASER_RANDOMNESS + (chaosIntervals * CHAOS_MULTIPLIER_PER_INTERVAL);\n\n    // Calculate the range of valid positions\n    const fullRange = this.centerY - this.minLaserY;\n    const randomRange = fullRange * currentChaos;\n    const centerPosition = this.minLaserY + (fullRange / 2);\n\n    // Generate random position within chaos-modified range\n    return centerPosition - (randomRange / 2) + (Math.random() * randomRange);\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  private initializeLasers(): void {\n    const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n    const firstLaserY = this.centerY;\n    const nextLaserY = this.generateRandomLaserY(0);\n\n    this.lasers = [\n      {\n        x: this.enemyX + currentEnemyWidth / 2, // Spawn from enemy center X\n        y: firstLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: nextLaserY, // Pre-calculate next position\n        width: this.getNextLaserWidth(), // Use new method for initial width\n      },\n    ];\n\n    // Set initial target\n    this.targetEnemyY = firstLaserY;\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score: number): void {\n    this.currentScore = score; // Update score for chaos calculation\n\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reduce speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      // Special case: Reset total speed to specific value at score 50 (3rd laser)\n      if (this.numLasers === 3) {\n        // Start smooth transition to new speed\n        this.transitionStartSpeed = this.getCurrentSpeed(score);\n        this.transitionTargetSpeed = LASER_SPEED_AT_SCORE_50;\n        this.transitionProgress = 0;\n        this.isTransitioningSpeed = true;\n\n        // Reset baseSpeed and track when we reset\n        this.baseSpeed = LASER_SPEED_AT_SCORE_50;\n        this.speedResetScore = score; // Remember we reset at this score\n      }\n      // Special case: Reset total speed to specific value at score 75 (4th laser)\n      else if (this.numLasers === 4) {\n        // Start smooth transition to new speed\n        this.transitionStartSpeed = this.getCurrentSpeed(score);\n        this.transitionTargetSpeed = LASER_SPEED_AT_SCORE_75;\n        this.transitionProgress = 0;\n        this.isTransitioningSpeed = true;\n\n        // Reset baseSpeed and track when we reset\n        this.baseSpeed = LASER_SPEED_AT_SCORE_75;\n        this.speedResetScore = score; // Remember we reset at this score\n      }\n      else {\n        this.baseSpeed = Math.max(1, this.baseSpeed - LASER_SPEED_REDUCTION_ON_UNLOCK);\n      }\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n      const newLaserY = this.generateRandomLaserY(score);\n      // When a new laser is added, ensure its initial width follows the alternating pattern\n      this.lasers.push({\n        x: this.enemyX + currentEnemyWidth / 2, // Spawn from enemy center X\n        y: newLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: this.generateRandomLaserY(score), // Pre-calculate next position\n        width: this.getNextLaserWidth(), // Use new method for new lasers\n      });\n    }\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Easing function for smooth transitions (ease-out cubic)\n   */\n  private easeOutCubic(t: number): number {\n    return 1 - Math.pow(1 - t, 3);\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   * Level 1 (0-99): Speed increases by LASER_SPEED_INCREMENT every SCORE_PER_SPEED_INCREMENT points\n   * Level 2 (100+): Speed stays constant at the value when entering Level 2\n   * Between scores 25-50, gradual reduction is applied\n   */\n  private getCurrentSpeed(score: number): number {\n    let speed: number;\n\n    // Level 2: Speed is constant (no incremental increases)\n    if (score >= 100) {\n      // If we've reset speed (at score 50 or 75), use that base speed\n      if (this.speedResetScore >= 0 && this.speedResetScore >= 50) {\n        speed = this.baseSpeed; // Just use base speed, no increments\n      } else {\n        // Calculate what the speed was at score 99 and keep it constant\n        const speedIncrements = Math.floor(99 / SCORE_PER_SPEED_INCREMENT);\n        speed = this.baseSpeed + (LASER_SPEED_INCREMENT * speedIncrements);\n      }\n    }\n    // Level 1: Normal incremental speed\n    else if (this.speedResetScore >= 0 && score > this.speedResetScore) {\n      // Calculate how many increments have happened since the reset\n      const incrementsSinceReset = Math.floor((score - this.speedResetScore) / SCORE_PER_SPEED_INCREMENT);\n      speed = this.baseSpeed + (LASER_SPEED_INCREMENT * incrementsSinceReset);\n    } else {\n      // Normal incremental speed calculation before reset\n      const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT);\n      speed = this.baseSpeed + (LASER_SPEED_INCREMENT * speedIncrements);\n\n      // Apply gradual reduction between scores 25-50\n      if (score > 25 && score < 50) {\n        const pointsPast25 = score - 25;\n        const reduction = pointsPast25 * LASER_SPEED_GRADUAL_REDUCTION;\n        speed -= reduction;\n      }\n    }\n\n    // If transitioning, interpolate between start and target speed\n    if (this.isTransitioningSpeed) {\n      const easedProgress = this.easeOutCubic(this.transitionProgress);\n      speed = this.transitionStartSpeed + (this.transitionTargetSpeed - this.transitionStartSpeed) * easedProgress;\n    }\n\n    return speed;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change, hit status, and enemy hit count\n   */\n  update(\n    score: number,\n    playerPosition: Position,\n    playerHasJumped: boolean\n  ): { scoreChange: number; wasHit: boolean; enemyHitCount: number } {\n    this.currentScore = score; // Update score for chaos calculation\n\n    // Update speed transition progress\n    if (this.isTransitioningSpeed) {\n      // Increment progress (assuming ~16.67ms per frame at 60 FPS)\n      this.transitionProgress += 16.67 / LASER_SPEED_TRANSITION_DURATION;\n      if (this.transitionProgress >= 1) {\n        this.transitionProgress = 1;\n        this.isTransitioningSpeed = false; // Transition complete\n      }\n    }\n\n    const currentSpeed = this.getCurrentSpeed(score);\n    let scoreChange = 0;\n    let wasHit = false;\n    let enemyHitCount = 0; // Track enemy hits on player\n\n    this.lasers.forEach((laser) => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      const laserWidth = laser.width || LASER_WIDTH;\n      if (laser.x + laserWidth < 0) {\n        const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n        const currentEnemyHeight = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE);\n        // Spawn laser from enemy's current center position\n        laser.x = this.enemyX + currentEnemyWidth / 2;\n        laser.y = this.enemyY + currentEnemyHeight / 2; // Spawn from enemy's current center Y\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n        // Use the new method for respawned lasers to maintain the alternating pattern\n        laser.width = this.getNextLaserWidth();\n        // Calculate the NEXT spawn position with chaos based on current score\n        laser.nextY = this.generateRandomLaserY(this.currentScore);\n\n        // Set up delayed movement to next position\n        this.pendingTargetY = laser.nextY;\n        this.movementDelayTimer = ENEMY_MOVEMENT_DELAY;\n      }\n\n      // Check collision with player (use laser's custom width if set)\n      const currentLaserWidth = laser.width || LASER_WIDTH;\n      if (\n        !laser.hit &&\n        playerPosition.x + BALL_SIZE > laser.x &&\n        playerPosition.x < laser.x + currentLaserWidth &&\n        playerPosition.y + BALL_SIZE > laser.y && // Player bottom vs laser top\n        playerPosition.y < laser.y + LASER_HEIGHT // Player top vs laser bottom\n      ) {\n        laser.hit = true;\n        wasHit = true;\n        enemyHitCount++; // Increment enemy hit counter\n\n        // Make laser disappear (respawn) when it hits the player\n        const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n        const currentEnemyHeight = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE);\n        laser.x = this.enemyX + currentEnemyWidth / 2;\n        laser.y = this.enemyY + currentEnemyHeight / 2;\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n        laser.width = this.getNextLaserWidth();\n        laser.nextY = this.generateRandomLaserY(this.currentScore);\n\n        // Set up delayed movement to next position\n        this.pendingTargetY = laser.nextY;\n        this.movementDelayTimer = ENEMY_MOVEMENT_DELAY;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (\n        !laser.scored &&\n        !laser.hit &&\n        playerHasJumped &&\n        playerPosition.x > laser.x + currentLaserWidth\n      ) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    // Handle movement delay timer\n    if (this.movementDelayTimer > 0) {\n      // Countdown the delay timer (assuming ~16.67ms per frame at 60 FPS)\n      this.movementDelayTimer -= 16.67;\n\n      // When delay expires, start moving to the pending target\n      if (this.movementDelayTimer <= 0 && this.pendingTargetY !== null) {\n        this.targetEnemyY = this.pendingTargetY;\n        this.pendingTargetY = null;\n        this.isSettling = false; // Reset settling mode for new movement\n      }\n    }\n\n    const previousY = this.enemyY;\n    const distanceToTarget = Math.abs(this.targetEnemyY - this.enemyY);\n\n    // Check if we should enter settling/oscillation mode\n    if (distanceToTarget < ENEMY_SETTLE_THRESHOLD && !this.isSettling) {\n      this.isSettling = true;\n      // Give it a strong initial bounce velocity for visible overshoot\n      // Direction depends on which way we're approaching\n      const direction = this.enemyY < this.targetEnemyY ? 1 : -1;\n      this.oscillationVelocity = direction * ENEMY_BOUNCE_AMPLITUDE;\n    }\n\n    if (this.isSettling) {\n      // Physics-based oscillation (like blue ball bouncing)\n      this.enemyY += this.oscillationVelocity;\n\n      // Check if we've crossed the target (bounce)\n      const crossedTarget =\n        (this.oscillationVelocity > 0 && this.enemyY > this.targetEnemyY) ||\n        (this.oscillationVelocity < 0 && this.enemyY < this.targetEnemyY);\n\n      if (crossedTarget) {\n        // Snap to target and reverse with damping\n        this.enemyY = this.targetEnemyY;\n        this.oscillationVelocity = -this.oscillationVelocity * ENEMY_OSCILLATION_DAMPING;\n      }\n\n      // Stop oscillating when velocity is too small\n      if (Math.abs(this.oscillationVelocity) < ENEMY_MIN_OSCILLATION_VELOCITY) {\n        this.oscillationVelocity = 0;\n        this.enemyY = this.targetEnemyY;\n      }\n    } else {\n      // Normal smooth interpolation when not settling\n      this.enemyY += (this.targetEnemyY - this.enemyY) * ENEMY_MOVE_SPEED;\n    }\n\n    // Calculate velocity for squash/stretch effect\n    this.enemyVelocity = this.enemyY - previousY;\n\n    return { scoreChange, wasHit, enemyHitCount };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers(): LaserState[] {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers(): number {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position (smoothly animated)\n   */\n  getEnemyY(): number {\n    return this.enemyY;\n  }\n\n  /**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   * Squishes in the direction of movement (like blue ball bouncing through liquid)\n   */\n  getEnemyScale(): number {\n    // Calculate the base scale factor based on growth level.\n    // Each growth level adds 0.25 to the base scale of 1.\n    // This directly implements the requirement: initial 1 + (growthLevel * 0.25).\n    return 1 + (this.enemyGrowthLevel * 0.25);\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset(): void {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.targetEnemyY = this.centerY;\n    this.laserSpawnCounter = 0; // Reset counter on game restart\n    this.enemyGrowthLevel = 0; // Reset growth on game restart\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth: number, screenHeight: number, centerY: number, enemyX: number): void {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyX = enemyX;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}