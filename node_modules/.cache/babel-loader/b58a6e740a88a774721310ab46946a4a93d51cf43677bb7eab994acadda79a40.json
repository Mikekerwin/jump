{"ast":null,"code":"/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n */import{LASER_WIDTH,LASER_HEIGHT,BASE_LASER_SPEED,LASER_SPEED_INCREMENT,MAX_LASERS,SCORE_PER_LASER_UNLOCK,SCORE_PER_SPEED_INCREMENT,SPEED_INCREMENTS_PER_CYCLE,BALL_SIZE}from'../config/gameConfig';export class LaserPhysics{constructor(screenWidth,screenHeight,centerY){this.lasers=[];this.numLasers=1;this.baseSpeed=BASE_LASER_SPEED;this.enemyY=void 0;this.screenWidth=void 0;this.centerY=void 0;this.minLaserY=void 0;this.screenWidth=screenWidth;this.centerY=centerY;this.minLaserY=screenHeight*0.5;this.enemyY=centerY;this.initializeLasers();}/**\n   * Initialize lasers at starting positions\n   */initializeLasers(){this.lasers=[{x:this.screenWidth,y:this.centerY,hit:false,scored:false,passed:false}];}/**\n   * Update laser count based on score\n   */updateLaserCount(score){const extraLasers=Math.floor(score/SCORE_PER_LASER_UNLOCK);const prevNumLasers=this.numLasers;this.numLasers=Math.min(extraLasers+1,MAX_LASERS);// Reset speed when new laser is added\nif(this.numLasers>prevNumLasers){this.baseSpeed=BASE_LASER_SPEED;}// Adjust laser array\nwhile(this.lasers.length<this.numLasers){this.lasers.push({x:this.screenWidth,y:this.centerY,hit:false,scored:false,passed:false});}while(this.lasers.length>this.numLasers){this.lasers.pop();}}/**\n   * Calculate current laser speed based on score\n   */getCurrentSpeed(score){const speedIncrements=Math.floor(score/SCORE_PER_SPEED_INCREMENT)%SPEED_INCREMENTS_PER_CYCLE;return this.baseSpeed+LASER_SPEED_INCREMENT*speedIncrements;}/**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */update(score,playerPosition,playerHasJumped){const currentSpeed=this.getCurrentSpeed(score);const spacing=this.screenWidth/this.numLasers;let scoreChange=0;let wasHit=false;let newEnemyY;this.lasers.forEach((laser,index)=>{// Move laser\nlaser.x-=currentSpeed;// Check if player passed without jumping (penalty)\nif(!laser.hit&&!laser.passed&&playerPosition.x>laser.x+LASER_WIDTH){laser.passed=true;if(!playerHasJumped){scoreChange-=1;}}// Respawn laser when off screen\nif(laser.x+LASER_WIDTH<0){laser.x=this.screenWidth+index*spacing;laser.hit=false;laser.scored=false;laser.passed=false;// Randomize Y position\nlaser.y=Math.random()*(this.centerY-this.minLaserY)+this.minLaserY;// Update enemy position to match new laser Y\nnewEnemyY=laser.y;}// Check collision with player\nif(!laser.hit&&playerPosition.x+BALL_SIZE>laser.x&&playerPosition.x<laser.x+LASER_WIDTH&&playerPosition.y+BALL_SIZE>laser.y&&playerPosition.y<laser.y+LASER_HEIGHT){laser.hit=true;wasHit=true;}// Check if player successfully jumped over laser (scoring)\nif(!laser.scored&&!laser.hit&&playerHasJumped&&playerPosition.x>laser.x+LASER_WIDTH){laser.scored=true;scoreChange+=1;}});return{scoreChange,wasHit,newEnemyY};}/**\n   * Get all laser states\n   */getLasers(){return this.lasers;}/**\n   * Get current number of active lasers\n   */getNumLasers(){return this.numLasers;}/**\n   * Get enemy Y position\n   */getEnemyY(){return this.enemyY;}/**\n   * Update enemy Y position\n   */setEnemyY(y){this.enemyY=y;}/**\n   * Reset laser system\n   */reset(){this.numLasers=1;this.baseSpeed=BASE_LASER_SPEED;this.enemyY=this.centerY;this.initializeLasers();}/**\n   * Update dimensions (for window resize)\n   */updateDimensions(screenWidth,screenHeight,centerY){this.screenWidth=screenWidth;this.centerY=centerY;this.minLaserY=screenHeight*0.5;}}","map":{"version":3,"names":["LASER_WIDTH","LASER_HEIGHT","BASE_LASER_SPEED","LASER_SPEED_INCREMENT","MAX_LASERS","SCORE_PER_LASER_UNLOCK","SCORE_PER_SPEED_INCREMENT","SPEED_INCREMENTS_PER_CYCLE","BALL_SIZE","LaserPhysics","constructor","screenWidth","screenHeight","centerY","lasers","numLasers","baseSpeed","enemyY","minLaserY","initializeLasers","x","y","hit","scored","passed","updateLaserCount","score","extraLasers","Math","floor","prevNumLasers","min","length","push","pop","getCurrentSpeed","speedIncrements","update","playerPosition","playerHasJumped","currentSpeed","spacing","scoreChange","wasHit","newEnemyY","forEach","laser","index","random","getLasers","getNumLasers","getEnemyY","setEnemyY","reset","updateDimensions"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/laserPhysics.ts"],"sourcesContent":["/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n */\n\nimport { LaserState, Position } from '../types/game';\nimport {\n  LASER_WIDTH,\n  LASER_HEIGHT,\n  BASE_LASER_SPEED,\n  LASER_SPEED_INCREMENT,\n  MAX_LASERS,\n  SCORE_PER_LASER_UNLOCK,\n  SCORE_PER_SPEED_INCREMENT,\n  SPEED_INCREMENTS_PER_CYCLE,\n  BALL_SIZE,\n} from '../config/gameConfig';\n\nexport class LaserPhysics {\n  private lasers: LaserState[] = [];\n  private numLasers: number = 1;\n  private baseSpeed: number = BASE_LASER_SPEED;\n  private enemyY: number;\n  private screenWidth: number;\n  private centerY: number;\n  private minLaserY: number;\n\n  constructor(screenWidth: number, screenHeight: number, centerY: number) {\n    this.screenWidth = screenWidth;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  private initializeLasers(): void {\n    this.lasers = [\n      {\n        x: this.screenWidth,\n        y: this.centerY,\n        hit: false,\n        scored: false,\n        passed: false,\n      },\n    ];\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score: number): void {\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reset speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      this.baseSpeed = BASE_LASER_SPEED;\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      this.lasers.push({\n        x: this.screenWidth,\n        y: this.centerY,\n        hit: false,\n        scored: false,\n        passed: false,\n      });\n    }\n\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   */\n  private getCurrentSpeed(score: number): number {\n    const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT) % SPEED_INCREMENTS_PER_CYCLE;\n    return this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */\n  update(\n    score: number,\n    playerPosition: Position,\n    playerHasJumped: boolean\n  ): { scoreChange: number; wasHit: boolean; newEnemyY?: number } {\n    const currentSpeed = this.getCurrentSpeed(score);\n    const spacing = this.screenWidth / this.numLasers;\n    let scoreChange = 0;\n    let wasHit = false;\n    let newEnemyY: number | undefined;\n\n    this.lasers.forEach((laser, index) => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      if (laser.x + LASER_WIDTH < 0) {\n        laser.x = this.screenWidth + index * spacing;\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n\n        // Randomize Y position\n        laser.y = Math.random() * (this.centerY - this.minLaserY) + this.minLaserY;\n\n        // Update enemy position to match new laser Y\n        newEnemyY = laser.y;\n      }\n\n      // Check collision with player\n      if (\n        !laser.hit &&\n        playerPosition.x + BALL_SIZE > laser.x &&\n        playerPosition.x < laser.x + LASER_WIDTH &&\n        playerPosition.y + BALL_SIZE > laser.y &&\n        playerPosition.y < laser.y + LASER_HEIGHT\n      ) {\n        laser.hit = true;\n        wasHit = true;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (\n        !laser.scored &&\n        !laser.hit &&\n        playerHasJumped &&\n        playerPosition.x > laser.x + LASER_WIDTH\n      ) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    return { scoreChange, wasHit, newEnemyY };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers(): LaserState[] {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers(): number {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position\n   */\n  getEnemyY(): number {\n    return this.enemyY;\n  }\n\n  /**\n   * Update enemy Y position\n   */\n  setEnemyY(y: number): void {\n    this.enemyY = y;\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset(): void {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth: number, screenHeight: number, centerY: number): void {\n    this.screenWidth = screenWidth;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}