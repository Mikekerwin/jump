{"ast":null,"code":"/**\n * Player Physics System\n * Handles player movement, gravity, jumping, and bouncing\n */\n\nimport { PLAYER_HORIZONTAL_RANGE_LEFT, PLAYER_HORIZONTAL_RANGE_RIGHT, GRAVITY, ENERGY_LOSS, BOOST, HOLD_BOOST, MAX_HOLD_TIME, MIN_BOUNCE_VELOCITY } from '../config/gameConfig';\nexport class PlayerPhysics {\n  constructor(initialX, initialY, centerY) {\n    this.playerState = void 0;\n    this.initialX = void 0;\n    this.centerY = void 0;\n    this.centerY = centerY;\n    this.initialX = initialX;\n    this.playerState = {\n      position: {\n        x: initialX,\n        y: initialY\n      },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0\n    };\n  }\n\n  /**\n   * Update player physics for one frame\n   */\n  update() {\n    // Apply gravity\n    this.playerState.velocity -= GRAVITY;\n\n    // Apply hold boost\n    if (this.playerState.isHolding) {\n      const heldTime = performance.now() - this.playerState.holdStartTime;\n      if (heldTime < MAX_HOLD_TIME) {\n        this.playerState.velocity += HOLD_BOOST;\n      } else {\n        this.playerState.isHolding = false;\n      }\n    }\n\n    // Update position\n    this.playerState.position.y -= this.playerState.velocity;\n\n    // Handle floor collision (bounce)\n    if (this.playerState.position.y > this.centerY) {\n      this.playerState.position.y = this.centerY;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n      this.playerState.hasJumped = false;\n\n      // Stop very small bounces\n      if (Math.abs(this.playerState.velocity) < MIN_BOUNCE_VELOCITY) {\n        this.playerState.velocity = 0;\n      }\n    }\n\n    // Handle ceiling collision\n    if (this.playerState.position.y < 0) {\n      this.playerState.position.y = 0;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n    }\n\n    // Update fluid scaling based on velocity and position\n    this.updateScaling();\n    return this.playerState;\n  }\n\n  /**\n   * Update player's horizontal position based on mouse/touch input.\n   * @param clientX The mouse's X coordinate.\n   * @param screenWidth The total width of the screen.\n   */\n  setMousePosition(clientX, screenWidth) {\n    const mouseRatio = clientX / screenWidth; // Mouse position as a ratio from 0.0 to 1.0\n    const minX = this.initialX - PLAYER_HORIZONTAL_RANGE_LEFT;\n    const maxX = this.initialX + PLAYER_HORIZONTAL_RANGE_RIGHT;\n    this.playerState.position.x = minX + mouseRatio * (maxX - minX);\n  }\n\n  /**\n   * Start a jump (initial press)\n   */\n  startJump() {\n    if (!this.playerState.hasJumped) {\n      this.playerState.velocity = BOOST;\n      this.playerState.hasJumped = true;\n    }\n    this.playerState.isHolding = true;\n    this.playerState.holdStartTime = performance.now();\n  }\n\n  /**\n   * Stop holding jump\n   */\n  endJump() {\n    this.playerState.isHolding = false;\n  }\n\n  /**\n   * Update player scaling for squash and stretch effect\n   */\n  updateScaling() {\n    let targetScaleX = 1;\n    let targetScaleY = 1;\n    if (Math.abs(this.playerState.velocity) > 0.1) {\n      if (this.playerState.velocity > 0) {\n        // Moving up - stretch vertically\n        targetScaleY = 1 - this.playerState.velocity / 50;\n        targetScaleX = 1 + this.playerState.velocity / 50;\n      } else {\n        // Moving down - stretch horizontally\n        targetScaleY = 1 + Math.abs(this.playerState.velocity) / 50;\n        targetScaleX = 1 - Math.abs(this.playerState.velocity) / 50;\n      }\n    }\n\n    // Squash when on ground\n    if (this.playerState.position.y >= this.centerY && Math.abs(this.playerState.velocity) < 0.5) {\n      targetScaleY = 0.7;\n      targetScaleX = 1.3;\n    }\n\n    // Return to normal when settled\n    if (Math.abs(this.playerState.velocity) < 0.01 && this.playerState.position.y >= this.centerY) {\n      targetScaleX = 1;\n      targetScaleY = 1;\n    }\n\n    // Smooth interpolation\n    this.playerState.scaleX += (targetScaleX - this.playerState.scaleX) * 0.15;\n    this.playerState.scaleY += (targetScaleY - this.playerState.scaleY) * 0.15;\n  }\n\n  /**\n   * Check if player should trigger a bounce sound\n   */\n  shouldPlayBounceSound() {\n    return this.playerState.position.y >= this.centerY && Math.abs(this.playerState.velocity) > MIN_BOUNCE_VELOCITY;\n  }\n\n  /**\n   * Get bounce volume based on velocity\n   */\n  getBounceVolume() {\n    return Math.min(Math.abs(this.playerState.velocity) / BOOST, 1);\n  }\n\n  /**\n   * Reset player to initial state\n   */\n  reset(initialX, initialY) {\n    this.initialX = initialX;\n    this.playerState = {\n      position: {\n        x: initialX,\n        y: initialY\n      },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0\n    };\n  }\n\n  /**\n   * Update center Y (for window resize)\n   */\n  updateCenterY(newCenterY) {\n    this.centerY = newCenterY;\n    // When resizing, we don't want to snap back to the initial Y if we're in the air\n    this.playerState.position.y = newCenterY;\n  }\n\n  /**\n   * Get current player state\n   */\n  getState() {\n    return this.playerState;\n  }\n\n  /**\n   * Check if player has jumped (for scoring)\n   */\n  hasPlayerJumped() {\n    return this.playerState.hasJumped;\n  }\n}","map":{"version":3,"names":["PLAYER_HORIZONTAL_RANGE_LEFT","PLAYER_HORIZONTAL_RANGE_RIGHT","GRAVITY","ENERGY_LOSS","BOOST","HOLD_BOOST","MAX_HOLD_TIME","MIN_BOUNCE_VELOCITY","PlayerPhysics","constructor","initialX","initialY","centerY","playerState","position","x","y","velocity","scaleX","scaleY","hasJumped","isHolding","holdStartTime","update","heldTime","performance","now","Math","abs","updateScaling","setMousePosition","clientX","screenWidth","mouseRatio","minX","maxX","startJump","endJump","targetScaleX","targetScaleY","shouldPlayBounceSound","getBounceVolume","min","reset","updateCenterY","newCenterY","getState","hasPlayerJumped"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/playerPhysics.ts"],"sourcesContent":["/**\n * Player Physics System\n * Handles player movement, gravity, jumping, and bouncing\n */\n\nimport { PlayerState } from '../types/game';\nimport {\n  PLAYER_HORIZONTAL_RANGE_LEFT,\n  PLAYER_HORIZONTAL_RANGE_RIGHT,\n  GRAVITY,\n  ENERGY_LOSS,\n  BOOST,\n  HOLD_BOOST,\n  MAX_HOLD_TIME,\n  MIN_BOUNCE_VELOCITY,\n} from '../config/gameConfig';\n\nexport class PlayerPhysics {\n  private playerState: PlayerState;\n  private initialX: number;\n  private centerY: number;\n\n  constructor(initialX: number, initialY: number, centerY: number) {\n    this.centerY = centerY;\n    this.initialX = initialX;\n    this.playerState = {\n      position: { x: initialX, y: initialY },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0,\n    };\n  }\n\n  /**\n   * Update player physics for one frame\n   */\n  update(): PlayerState {\n    // Apply gravity\n    this.playerState.velocity -= GRAVITY;\n\n    // Apply hold boost\n    if (this.playerState.isHolding) {\n      const heldTime = performance.now() - this.playerState.holdStartTime;\n      if (heldTime < MAX_HOLD_TIME) {\n        this.playerState.velocity += HOLD_BOOST;\n      } else {\n        this.playerState.isHolding = false;\n      }\n    }\n\n    // Update position\n    this.playerState.position.y -= this.playerState.velocity;\n\n    // Handle floor collision (bounce)\n    if (this.playerState.position.y > this.centerY) {\n      this.playerState.position.y = this.centerY;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n      this.playerState.hasJumped = false;\n\n      // Stop very small bounces\n      if (Math.abs(this.playerState.velocity) < MIN_BOUNCE_VELOCITY) {\n        this.playerState.velocity = 0;\n      }\n    }\n\n    // Handle ceiling collision\n    if (this.playerState.position.y < 0) {\n      this.playerState.position.y = 0;\n      this.playerState.velocity = -this.playerState.velocity * ENERGY_LOSS;\n    }\n\n    // Update fluid scaling based on velocity and position\n    this.updateScaling();\n\n    return this.playerState;\n  }\n\n  /**\n   * Update player's horizontal position based on mouse/touch input.\n   * @param clientX The mouse's X coordinate.\n   * @param screenWidth The total width of the screen.\n   */\n  setMousePosition(clientX: number, screenWidth: number): void {\n    const mouseRatio = clientX / screenWidth; // Mouse position as a ratio from 0.0 to 1.0\n    const minX = this.initialX - PLAYER_HORIZONTAL_RANGE_LEFT;\n    const maxX = this.initialX + PLAYER_HORIZONTAL_RANGE_RIGHT;\n    this.playerState.position.x = minX + (mouseRatio * (maxX - minX));\n  }\n\n  /**\n   * Start a jump (initial press)\n   */\n  startJump(): void {\n    if (!this.playerState.hasJumped) {\n      this.playerState.velocity = BOOST;\n      this.playerState.hasJumped = true;\n    }\n    this.playerState.isHolding = true;\n    this.playerState.holdStartTime = performance.now();\n  }\n\n  /**\n   * Stop holding jump\n   */\n  endJump(): void {\n    this.playerState.isHolding = false;\n  }\n\n  /**\n   * Update player scaling for squash and stretch effect\n   */\n  private updateScaling(): void {\n    let targetScaleX = 1;\n    let targetScaleY = 1;\n\n    if (Math.abs(this.playerState.velocity) > 0.1) {\n      if (this.playerState.velocity > 0) {\n        // Moving up - stretch vertically\n        targetScaleY = 1 - this.playerState.velocity / 50;\n        targetScaleX = 1 + this.playerState.velocity / 50;\n      } else {\n        // Moving down - stretch horizontally\n        targetScaleY = 1 + Math.abs(this.playerState.velocity) / 50;\n        targetScaleX = 1 - Math.abs(this.playerState.velocity) / 50;\n      }\n    }\n\n    // Squash when on ground\n    if (\n      this.playerState.position.y >= this.centerY &&\n      Math.abs(this.playerState.velocity) < 0.5\n    ) {\n      targetScaleY = 0.7;\n      targetScaleX = 1.3;\n    }\n\n    // Return to normal when settled\n    if (\n      Math.abs(this.playerState.velocity) < 0.01 &&\n      this.playerState.position.y >= this.centerY\n    ) {\n      targetScaleX = 1;\n      targetScaleY = 1;\n    }\n\n    // Smooth interpolation\n    this.playerState.scaleX += (targetScaleX - this.playerState.scaleX) * 0.15;\n    this.playerState.scaleY += (targetScaleY - this.playerState.scaleY) * 0.15;\n  }\n\n  /**\n   * Check if player should trigger a bounce sound\n   */\n  shouldPlayBounceSound(): boolean {\n    return (\n      this.playerState.position.y >= this.centerY &&\n      Math.abs(this.playerState.velocity) > MIN_BOUNCE_VELOCITY\n    );\n  }\n\n  /**\n   * Get bounce volume based on velocity\n   */\n  getBounceVolume(): number {\n    return Math.min(Math.abs(this.playerState.velocity) / BOOST, 1);\n  }\n\n  /**\n   * Reset player to initial state\n   */\n  reset(initialX: number, initialY: number): void {\n    this.initialX = initialX;\n    this.playerState = {\n      position: { x: initialX, y: initialY },\n      velocity: 0,\n      scaleX: 1,\n      scaleY: 1,\n      hasJumped: false,\n      isHolding: false,\n      holdStartTime: 0,\n    };\n  }\n\n  /**\n   * Update center Y (for window resize)\n   */\n  updateCenterY(newCenterY: number): void {\n    this.centerY = newCenterY;\n    // When resizing, we don't want to snap back to the initial Y if we're in the air\n    this.playerState.position.y = newCenterY;\n  }\n\n  /**\n   * Get current player state\n   */\n  getState(): PlayerState {\n    return this.playerState;\n  }\n\n  /**\n   * Check if player has jumped (for scoring)\n   */\n  hasPlayerJumped(): boolean {\n    return this.playerState.hasJumped;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}