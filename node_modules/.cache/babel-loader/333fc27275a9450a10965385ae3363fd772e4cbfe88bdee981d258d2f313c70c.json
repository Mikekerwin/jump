{"ast":null,"code":"/**\n * Scrolling Background System\n * Handles smooth horizontal scrolling of repeating background image\n */\n\nimport { BACKGROUND_SCROLL_SPEED, BACKGROUND_HEIGHT_SCALE } from '../config/gameConfig';\nexport class ScrollingBackground {\n  constructor(imagePath) {\n    this.offsetX = 0;\n    this.imageWidth = 0;\n    this.imageHeight = 0;\n    this.image = null;\n    this.imageLoaded = false;\n    this.image = new Image();\n    this.image.onload = () => {\n      this.imageWidth = this.image.width;\n      this.imageHeight = this.image.height;\n      this.imageLoaded = true;\n      console.log(`Background image loaded: ${imagePath} (${this.imageWidth}x${this.imageHeight})`);\n    };\n    this.image.onerror = error => {\n      console.error(`Failed to load background image: ${imagePath}`, error);\n    };\n    this.image.src = imagePath;\n    console.log(`Loading background image from: ${imagePath}`);\n  }\n\n  /**\n   * Update background offset for scrolling animation\n   */\n  update() {\n    if (!this.imageLoaded) return;\n\n    // Move background to the left\n    this.offsetX -= BACKGROUND_SCROLL_SPEED;\n\n    // Reset offset when it reaches the image width for seamless loop\n    if (Math.abs(this.offsetX) >= this.imageWidth) {\n      this.offsetX = 0;\n    }\n  }\n\n  /**\n   * Render the scrolling background\n   */\n  render(ctx, canvasWidth, canvasHeight) {\n    if (!this.imageLoaded || !this.image) return;\n\n    // Calculate scale to fit height with additional height scale factor\n    const scale = canvasHeight * BACKGROUND_HEIGHT_SCALE / this.imageHeight;\n    const scaledWidth = this.imageWidth * scale;\n    const scaledHeight = this.imageHeight * scale;\n\n    // Anchor to bottom of screen (extra height grows upwards)\n    const yOffset = canvasHeight - scaledHeight;\n\n    // Draw multiple copies to fill the screen and create seamless scrolling\n    const numCopies = Math.ceil(canvasWidth / scaledWidth) + 2;\n    for (let i = 0; i < numCopies; i++) {\n      const x = this.offsetX + i * scaledWidth;\n      ctx.drawImage(this.image, x, yOffset, scaledWidth, scaledHeight);\n    }\n  }\n\n  /**\n   * Reset background position\n   */\n  reset() {\n    this.offsetX = 0;\n  }\n\n  /**\n   * Update dimensions if window is resized\n   */\n  updateDimensions(_width, _height) {\n    // Background scales automatically based on canvas size\n    // No additional updates needed\n  }\n}","map":{"version":3,"names":["BACKGROUND_SCROLL_SPEED","BACKGROUND_HEIGHT_SCALE","ScrollingBackground","constructor","imagePath","offsetX","imageWidth","imageHeight","image","imageLoaded","Image","onload","width","height","console","log","onerror","error","src","update","Math","abs","render","ctx","canvasWidth","canvasHeight","scale","scaledWidth","scaledHeight","yOffset","numCopies","ceil","i","x","drawImage","reset","updateDimensions","_width","_height"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/scrollingBackground.ts"],"sourcesContent":["/**\n * Scrolling Background System\n * Handles smooth horizontal scrolling of repeating background image\n */\n\nimport { BACKGROUND_SCROLL_SPEED, BACKGROUND_HEIGHT_SCALE } from '../config/gameConfig';\n\nexport class ScrollingBackground {\n  private offsetX: number = 0;\n  private imageWidth: number = 0;\n  private imageHeight: number = 0;\n  private image: HTMLImageElement | null = null;\n  private imageLoaded: boolean = false;\n\n  constructor(imagePath: string) {\n    this.image = new Image();\n    this.image.onload = () => {\n      this.imageWidth = this.image!.width;\n      this.imageHeight = this.image!.height;\n      this.imageLoaded = true;\n      console.log(`Background image loaded: ${imagePath} (${this.imageWidth}x${this.imageHeight})`);\n    };\n    this.image.onerror = (error) => {\n      console.error(`Failed to load background image: ${imagePath}`, error);\n    };\n    this.image.src = imagePath;\n    console.log(`Loading background image from: ${imagePath}`);\n  }\n\n  /**\n   * Update background offset for scrolling animation\n   */\n  update(): void {\n    if (!this.imageLoaded) return;\n\n    // Move background to the left\n    this.offsetX -= BACKGROUND_SCROLL_SPEED;\n\n    // Reset offset when it reaches the image width for seamless loop\n    if (Math.abs(this.offsetX) >= this.imageWidth) {\n      this.offsetX = 0;\n    }\n  }\n\n  /**\n   * Render the scrolling background\n   */\n  render(ctx: CanvasRenderingContext2D, canvasWidth: number, canvasHeight: number): void {\n    if (!this.imageLoaded || !this.image) return;\n\n    // Calculate scale to fit height with additional height scale factor\n    const scale = (canvasHeight * BACKGROUND_HEIGHT_SCALE) / this.imageHeight;\n    const scaledWidth = this.imageWidth * scale;\n    const scaledHeight = this.imageHeight * scale;\n\n    // Anchor to bottom of screen (extra height grows upwards)\n    const yOffset = canvasHeight - scaledHeight;\n\n    // Draw multiple copies to fill the screen and create seamless scrolling\n    const numCopies = Math.ceil(canvasWidth / scaledWidth) + 2;\n\n    for (let i = 0; i < numCopies; i++) {\n      const x = this.offsetX + (i * scaledWidth);\n      ctx.drawImage(\n        this.image,\n        x,\n        yOffset,\n        scaledWidth,\n        scaledHeight\n      );\n    }\n  }\n\n  /**\n   * Reset background position\n   */\n  reset(): void {\n    this.offsetX = 0;\n  }\n\n  /**\n   * Update dimensions if window is resized\n   */\n  updateDimensions(_width: number, _height: number): void {\n    // Background scales automatically based on canvas size\n    // No additional updates needed\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;;AAEA,SAASA,uBAAuB,EAAEC,uBAAuB,QAAQ,sBAAsB;AAEvF,OAAO,MAAMC,mBAAmB,CAAC;EAO/BC,WAAWA,CAACC,SAAiB,EAAE;IAAA,KANvBC,OAAO,GAAW,CAAC;IAAA,KACnBC,UAAU,GAAW,CAAC;IAAA,KACtBC,WAAW,GAAW,CAAC;IAAA,KACvBC,KAAK,GAA4B,IAAI;IAAA,KACrCC,WAAW,GAAY,KAAK;IAGlC,IAAI,CAACD,KAAK,GAAG,IAAIE,KAAK,CAAC,CAAC;IACxB,IAAI,CAACF,KAAK,CAACG,MAAM,GAAG,MAAM;MACxB,IAAI,CAACL,UAAU,GAAG,IAAI,CAACE,KAAK,CAAEI,KAAK;MACnC,IAAI,CAACL,WAAW,GAAG,IAAI,CAACC,KAAK,CAAEK,MAAM;MACrC,IAAI,CAACJ,WAAW,GAAG,IAAI;MACvBK,OAAO,CAACC,GAAG,CAAC,4BAA4BX,SAAS,KAAK,IAAI,CAACE,UAAU,IAAI,IAAI,CAACC,WAAW,GAAG,CAAC;IAC/F,CAAC;IACD,IAAI,CAACC,KAAK,CAACQ,OAAO,GAAIC,KAAK,IAAK;MAC9BH,OAAO,CAACG,KAAK,CAAC,oCAAoCb,SAAS,EAAE,EAAEa,KAAK,CAAC;IACvE,CAAC;IACD,IAAI,CAACT,KAAK,CAACU,GAAG,GAAGd,SAAS;IAC1BU,OAAO,CAACC,GAAG,CAAC,kCAAkCX,SAAS,EAAE,CAAC;EAC5D;;EAEA;AACF;AACA;EACEe,MAAMA,CAAA,EAAS;IACb,IAAI,CAAC,IAAI,CAACV,WAAW,EAAE;;IAEvB;IACA,IAAI,CAACJ,OAAO,IAAIL,uBAAuB;;IAEvC;IACA,IAAIoB,IAAI,CAACC,GAAG,CAAC,IAAI,CAAChB,OAAO,CAAC,IAAI,IAAI,CAACC,UAAU,EAAE;MAC7C,IAAI,CAACD,OAAO,GAAG,CAAC;IAClB;EACF;;EAEA;AACF;AACA;EACEiB,MAAMA,CAACC,GAA6B,EAAEC,WAAmB,EAAEC,YAAoB,EAAQ;IACrF,IAAI,CAAC,IAAI,CAAChB,WAAW,IAAI,CAAC,IAAI,CAACD,KAAK,EAAE;;IAEtC;IACA,MAAMkB,KAAK,GAAID,YAAY,GAAGxB,uBAAuB,GAAI,IAAI,CAACM,WAAW;IACzE,MAAMoB,WAAW,GAAG,IAAI,CAACrB,UAAU,GAAGoB,KAAK;IAC3C,MAAME,YAAY,GAAG,IAAI,CAACrB,WAAW,GAAGmB,KAAK;;IAE7C;IACA,MAAMG,OAAO,GAAGJ,YAAY,GAAGG,YAAY;;IAE3C;IACA,MAAME,SAAS,GAAGV,IAAI,CAACW,IAAI,CAACP,WAAW,GAAGG,WAAW,CAAC,GAAG,CAAC;IAE1D,KAAK,IAAIK,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGF,SAAS,EAAEE,CAAC,EAAE,EAAE;MAClC,MAAMC,CAAC,GAAG,IAAI,CAAC5B,OAAO,GAAI2B,CAAC,GAAGL,WAAY;MAC1CJ,GAAG,CAACW,SAAS,CACX,IAAI,CAAC1B,KAAK,EACVyB,CAAC,EACDJ,OAAO,EACPF,WAAW,EACXC,YACF,CAAC;IACH;EACF;;EAEA;AACF;AACA;EACEO,KAAKA,CAAA,EAAS;IACZ,IAAI,CAAC9B,OAAO,GAAG,CAAC;EAClB;;EAEA;AACF;AACA;EACE+B,gBAAgBA,CAACC,MAAc,EAAEC,OAAe,EAAQ;IACtD;IACA;EAAA;AAEJ","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}