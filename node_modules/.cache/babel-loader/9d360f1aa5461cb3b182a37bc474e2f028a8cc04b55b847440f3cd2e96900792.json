{"ast":null,"code":"/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n */\n\nimport { LASER_WIDTH, LASER_HEIGHT, BASE_LASER_SPEED, LASER_SPEED_INCREMENT, MAX_LASERS, SCORE_PER_LASER_UNLOCK, SCORE_PER_SPEED_INCREMENT, SPEED_INCREMENTS_PER_CYCLE, BALL_SIZE } from '../config/gameConfig';\nexport class LaserPhysics {\n  constructor(screenWidth, screenHeight, centerY) {\n    this.lasers = [];\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = void 0;\n    this.screenWidth = void 0;\n    this.centerY = void 0;\n    this.minLaserY = void 0;\n    this.screenWidth = screenWidth;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  initializeLasers() {\n    this.lasers = [{\n      x: this.screenWidth,\n      y: this.centerY,\n      hit: false,\n      scored: false,\n      passed: false\n    }];\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score) {\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reset speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      this.baseSpeed = BASE_LASER_SPEED;\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      this.lasers.push({\n        x: this.screenWidth,\n        y: this.centerY,\n        hit: false,\n        scored: false,\n        passed: false\n      });\n    }\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   */\n  getCurrentSpeed(score) {\n    const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT) % SPEED_INCREMENTS_PER_CYCLE;\n    return this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */\n  update(score, playerPosition, playerHasJumped) {\n    const currentSpeed = this.getCurrentSpeed(score);\n    const spacing = this.screenWidth / this.numLasers;\n    let scoreChange = 0;\n    let wasHit = false;\n    let newEnemyY;\n    this.lasers.forEach((laser, index) => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      if (laser.x + LASER_WIDTH < 0) {\n        laser.x = this.screenWidth + index * spacing;\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n\n        // Randomize Y position\n        laser.y = Math.random() * (this.centerY - this.minLaserY) + this.minLaserY;\n\n        // Update enemy position to match new laser Y\n        newEnemyY = laser.y;\n      }\n\n      // Check collision with player\n      if (!laser.hit && playerPosition.x + BALL_SIZE > laser.x && playerPosition.x < laser.x + LASER_WIDTH && playerPosition.y + BALL_SIZE > laser.y && playerPosition.y < laser.y + LASER_HEIGHT) {\n        laser.hit = true;\n        wasHit = true;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (!laser.scored && !laser.hit && playerHasJumped && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n    return {\n      scoreChange,\n      wasHit,\n      newEnemyY\n    };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers() {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers() {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position\n   */\n  getEnemyY() {\n    return this.enemyY;\n  }\n\n  /**\n   * Update enemy Y position\n   */\n  setEnemyY(y) {\n    this.enemyY = y;\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset() {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth, screenHeight, centerY) {\n    this.screenWidth = screenWidth;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n  }\n}","map":{"version":3,"names":["LASER_WIDTH","LASER_HEIGHT","BASE_LASER_SPEED","LASER_SPEED_INCREMENT","MAX_LASERS","SCORE_PER_LASER_UNLOCK","SCORE_PER_SPEED_INCREMENT","SPEED_INCREMENTS_PER_CYCLE","BALL_SIZE","LaserPhysics","constructor","screenWidth","screenHeight","centerY","lasers","numLasers","baseSpeed","enemyY","minLaserY","initializeLasers","x","y","hit","scored","passed","updateLaserCount","score","extraLasers","Math","floor","prevNumLasers","min","length","push","pop","getCurrentSpeed","speedIncrements","update","playerPosition","playerHasJumped","currentSpeed","spacing","scoreChange","wasHit","newEnemyY","forEach","laser","index","random","getLasers","getNumLasers","getEnemyY","setEnemyY","reset","updateDimensions"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/laserPhysics.ts"],"sourcesContent":["/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n */\n\nimport { LaserState, Position } from '../types/game';\nimport {\n  LASER_WIDTH,\n  LASER_HEIGHT,\n  BASE_LASER_SPEED,\n  LASER_SPEED_INCREMENT,\n  MAX_LASERS,\n  SCORE_PER_LASER_UNLOCK,\n  SCORE_PER_SPEED_INCREMENT,\n  SPEED_INCREMENTS_PER_CYCLE,\n  BALL_SIZE,\n} from '../config/gameConfig';\n\nexport class LaserPhysics {\n  private lasers: LaserState[] = [];\n  private numLasers: number = 1;\n  private baseSpeed: number = BASE_LASER_SPEED;\n  private enemyY: number;\n  private screenWidth: number;\n  private centerY: number;\n  private minLaserY: number;\n\n  constructor(screenWidth: number, screenHeight: number, centerY: number) {\n    this.screenWidth = screenWidth;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  private initializeLasers(): void {\n    this.lasers = [\n      {\n        x: this.screenWidth,\n        y: this.centerY,\n        hit: false,\n        scored: false,\n        passed: false,\n      },\n    ];\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score: number): void {\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reset speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      this.baseSpeed = BASE_LASER_SPEED;\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      this.lasers.push({\n        x: this.screenWidth,\n        y: this.centerY,\n        hit: false,\n        scored: false,\n        passed: false,\n      });\n    }\n\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   */\n  private getCurrentSpeed(score: number): number {\n    const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT) % SPEED_INCREMENTS_PER_CYCLE;\n    return this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */\n  update(\n    score: number,\n    playerPosition: Position,\n    playerHasJumped: boolean\n  ): { scoreChange: number; wasHit: boolean; newEnemyY?: number } {\n    const currentSpeed = this.getCurrentSpeed(score);\n    const spacing = this.screenWidth / this.numLasers;\n    let scoreChange = 0;\n    let wasHit = false;\n    let newEnemyY: number | undefined;\n\n    this.lasers.forEach((laser, index) => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      if (laser.x + LASER_WIDTH < 0) {\n        laser.x = this.screenWidth + index * spacing;\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n\n        // Randomize Y position\n        laser.y = Math.random() * (this.centerY - this.minLaserY) + this.minLaserY;\n\n        // Update enemy position to match new laser Y\n        newEnemyY = laser.y;\n      }\n\n      // Check collision with player\n      if (\n        !laser.hit &&\n        playerPosition.x + BALL_SIZE > laser.x &&\n        playerPosition.x < laser.x + LASER_WIDTH &&\n        playerPosition.y + BALL_SIZE > laser.y &&\n        playerPosition.y < laser.y + LASER_HEIGHT\n      ) {\n        laser.hit = true;\n        wasHit = true;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (\n        !laser.scored &&\n        !laser.hit &&\n        playerHasJumped &&\n        playerPosition.x > laser.x + LASER_WIDTH\n      ) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    return { scoreChange, wasHit, newEnemyY };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers(): LaserState[] {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers(): number {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position\n   */\n  getEnemyY(): number {\n    return this.enemyY;\n  }\n\n  /**\n   * Update enemy Y position\n   */\n  setEnemyY(y: number): void {\n    this.enemyY = y;\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset(): void {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth: number, screenHeight: number, centerY: number): void {\n    this.screenWidth = screenWidth;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}