{"ast":null,"code":"/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */import{LASER_WIDTH,LASER_HEIGHT,BASE_LASER_SPEED,LASER_SPEED_INCREMENT,MAX_LASERS,SCORE_PER_LASER_UNLOCK,SCORE_PER_SPEED_INCREMENT,SPEED_INCREMENTS_PER_CYCLE,BALL_SIZE,ENEMY_MOVE_SPEED}from'../config/gameConfig';export class LaserPhysics{constructor(screenWidth,screenHeight,centerY,enemyX){this.lasers=[];this.numLasers=1;this.baseSpeed=BASE_LASER_SPEED;this.enemyY=void 0;this.targetEnemyY=void 0;// Target Y position for smooth movement\nthis.enemyVelocity=0;// Track movement velocity for squash/stretch\nthis.centerY=void 0;this.minLaserY=void 0;this.enemyX=void 0;this.centerY=centerY;this.minLaserY=screenHeight*0.5;this.enemyY=centerY;this.targetEnemyY=centerY;this.enemyX=enemyX;this.initializeLasers();}/**\n   * Generate a random Y position for laser spawn\n   * Adjusted to account for ball size so laser comes from center\n   */generateRandomLaserY(){return Math.random()*(this.centerY-this.minLaserY)+this.minLaserY;}/**\n   * Initialize lasers at starting positions\n   */initializeLasers(){const firstLaserY=this.centerY;const nextLaserY=this.generateRandomLaserY();this.lasers=[{x:this.enemyX+BALL_SIZE/2,// Spawn from enemy center X\ny:firstLaserY,hit:false,scored:false,passed:false,nextY:nextLaserY// Pre-calculate next position\n}];// Set initial target\nthis.targetEnemyY=firstLaserY;}/**\n   * Update laser count based on score\n   */updateLaserCount(score){const extraLasers=Math.floor(score/SCORE_PER_LASER_UNLOCK);const prevNumLasers=this.numLasers;this.numLasers=Math.min(extraLasers+1,MAX_LASERS);// Reset speed when new laser is added\nif(this.numLasers>prevNumLasers){this.baseSpeed=BASE_LASER_SPEED;}// Adjust laser array\nwhile(this.lasers.length<this.numLasers){const newLaserY=this.generateRandomLaserY();this.lasers.push({x:this.enemyX+BALL_SIZE/2,// Spawn from enemy center X\ny:newLaserY,hit:false,scored:false,passed:false,nextY:this.generateRandomLaserY()});}while(this.lasers.length>this.numLasers){this.lasers.pop();}}/**\n   * Calculate current laser speed based on score\n   */getCurrentSpeed(score){const speedIncrements=Math.floor(score/SCORE_PER_SPEED_INCREMENT)%SPEED_INCREMENTS_PER_CYCLE;return this.baseSpeed+LASER_SPEED_INCREMENT*speedIncrements;}/**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */update(score,playerPosition,playerHasJumped){const currentSpeed=this.getCurrentSpeed(score);let scoreChange=0;let wasHit=false;this.lasers.forEach(laser=>{// Move laser\nlaser.x-=currentSpeed;// Check if player passed without jumping (penalty)\nif(!laser.hit&&!laser.passed&&playerPosition.x>laser.x+LASER_WIDTH){laser.passed=true;if(!playerHasJumped){scoreChange-=1;}}// Respawn laser when off screen\nif(laser.x+LASER_WIDTH<0){// Use the pre-calculated Y position\nconst newY=laser.nextY!==undefined?laser.nextY:this.generateRandomLaserY();// Immediately set enemy target to this position so it starts moving\nthis.targetEnemyY=newY;// Spawn laser from enemy's current center position\nlaser.x=this.enemyX+BALL_SIZE/2;laser.y=this.enemyY+BALL_SIZE/2;// Spawn from enemy's current center Y\nlaser.hit=false;laser.scored=false;laser.passed=false;// Calculate the NEXT spawn position (for the next cycle)\nlaser.nextY=this.generateRandomLaserY();}// Check collision with player\nif(!laser.hit&&playerPosition.x+BALL_SIZE>laser.x&&playerPosition.x<laser.x+LASER_WIDTH&&playerPosition.y+BALL_SIZE>laser.y&&playerPosition.y<laser.y+LASER_HEIGHT){laser.hit=true;wasHit=true;}// Check if player successfully jumped over laser (scoring)\nif(!laser.scored&&!laser.hit&&playerHasJumped&&playerPosition.x>laser.x+LASER_WIDTH){laser.scored=true;scoreChange+=1;}});// Smoothly interpolate enemy Y position every frame\n// Enemy is always moving toward targetEnemyY\nconst previousY=this.enemyY;this.enemyY+=(this.targetEnemyY-this.enemyY)*ENEMY_MOVE_SPEED;// Calculate velocity for squash/stretch effect\nthis.enemyVelocity=this.enemyY-previousY;return{scoreChange,wasHit};}/**\n   * Get all laser states\n   */getLasers(){return this.lasers;}/**\n   * Get current number of active lasers\n   */getNumLasers(){return this.numLasers;}/**\n   * Get enemy Y position (smoothly animated)\n   */getEnemyY(){return this.enemyY;}/**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   */getEnemyScale(){// Calculate squash/stretch based on velocity\n// Moving down (positive velocity) = stretch vertically\n// Moving up (negative velocity) = stretch horizontally\nconst velocityFactor=Math.abs(this.enemyVelocity)*2;// Amplify for visibility\nlet scaleX=1;let scaleY=1;if(Math.abs(this.enemyVelocity)>0.1){if(this.enemyVelocity>0){// Moving down - stretch vertically, squash horizontally\nscaleY=1+velocityFactor;scaleX=1-velocityFactor*0.5;}else{// Moving up - stretch horizontally, squash vertically\nscaleX=1+velocityFactor;scaleY=1-velocityFactor*0.5;}}// Clamp values to reasonable ranges\nscaleX=Math.max(0.7,Math.min(1.3,scaleX));scaleY=Math.max(0.7,Math.min(1.3,scaleY));return{scaleX,scaleY};}/**\n   * Reset laser system\n   */reset(){this.numLasers=1;this.baseSpeed=BASE_LASER_SPEED;this.enemyY=this.centerY;this.targetEnemyY=this.centerY;this.initializeLasers();}/**\n   * Update dimensions (for window resize)\n   */updateDimensions(screenWidth,screenHeight,centerY,enemyX){this.centerY=centerY;this.minLaserY=screenHeight*0.5;this.enemyX=enemyX;}}","map":{"version":3,"names":["LASER_WIDTH","LASER_HEIGHT","BASE_LASER_SPEED","LASER_SPEED_INCREMENT","MAX_LASERS","SCORE_PER_LASER_UNLOCK","SCORE_PER_SPEED_INCREMENT","SPEED_INCREMENTS_PER_CYCLE","BALL_SIZE","ENEMY_MOVE_SPEED","LaserPhysics","constructor","screenWidth","screenHeight","centerY","enemyX","lasers","numLasers","baseSpeed","enemyY","targetEnemyY","enemyVelocity","minLaserY","initializeLasers","generateRandomLaserY","Math","random","firstLaserY","nextLaserY","x","y","hit","scored","passed","nextY","updateLaserCount","score","extraLasers","floor","prevNumLasers","min","length","newLaserY","push","pop","getCurrentSpeed","speedIncrements","update","playerPosition","playerHasJumped","currentSpeed","scoreChange","wasHit","forEach","laser","newY","undefined","previousY","getLasers","getNumLasers","getEnemyY","getEnemyScale","velocityFactor","abs","scaleX","scaleY","max","reset","updateDimensions"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/laserPhysics.ts"],"sourcesContent":["/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */\n\nimport { LaserState, Position } from '../types/game';\nimport {\n  LASER_WIDTH,\n  LASER_HEIGHT,\n  BASE_LASER_SPEED,\n  LASER_SPEED_INCREMENT,\n  MAX_LASERS,\n  SCORE_PER_LASER_UNLOCK,\n  SCORE_PER_SPEED_INCREMENT,\n  SPEED_INCREMENTS_PER_CYCLE,\n  BALL_SIZE,\n  ENEMY_MOVE_SPEED,\n} from '../config/gameConfig';\n\nexport class LaserPhysics {\n  private lasers: LaserState[] = [];\n  private numLasers: number = 1;\n  private baseSpeed: number = BASE_LASER_SPEED;\n  private enemyY: number;\n  private targetEnemyY: number; // Target Y position for smooth movement\n  private enemyVelocity: number = 0; // Track movement velocity for squash/stretch\n  private centerY: number;\n  private minLaserY: number;\n  private enemyX: number;\n\n  constructor(screenWidth: number, screenHeight: number, centerY: number, enemyX: number) {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.targetEnemyY = centerY;\n    this.enemyX = enemyX;\n    this.initializeLasers();\n  }\n\n  /**\n   * Generate a random Y position for laser spawn\n   * Adjusted to account for ball size so laser comes from center\n   */\n  private generateRandomLaserY(): number {\n    return Math.random() * (this.centerY - this.minLaserY) + this.minLaserY;\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  private initializeLasers(): void {\n    const firstLaserY = this.centerY;\n    const nextLaserY = this.generateRandomLaserY();\n\n    this.lasers = [\n      {\n        x: this.enemyX + BALL_SIZE / 2, // Spawn from enemy center X\n        y: firstLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: nextLaserY, // Pre-calculate next position\n      },\n    ];\n\n    // Set initial target\n    this.targetEnemyY = firstLaserY;\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score: number): void {\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reset speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      this.baseSpeed = BASE_LASER_SPEED;\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      const newLaserY = this.generateRandomLaserY();\n      this.lasers.push({\n        x: this.enemyX + BALL_SIZE / 2, // Spawn from enemy center X\n        y: newLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: this.generateRandomLaserY(),\n      });\n    }\n\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   */\n  private getCurrentSpeed(score: number): number {\n    const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT) % SPEED_INCREMENTS_PER_CYCLE;\n    return this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */\n  update(\n    score: number,\n    playerPosition: Position,\n    playerHasJumped: boolean\n  ): { scoreChange: number; wasHit: boolean } {\n    const currentSpeed = this.getCurrentSpeed(score);\n    let scoreChange = 0;\n    let wasHit = false;\n\n    this.lasers.forEach((laser) => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      if (laser.x + LASER_WIDTH < 0) {\n        // Use the pre-calculated Y position\n        const newY = laser.nextY !== undefined ? laser.nextY : this.generateRandomLaserY();\n\n        // Immediately set enemy target to this position so it starts moving\n        this.targetEnemyY = newY;\n\n        // Spawn laser from enemy's current center position\n        laser.x = this.enemyX + BALL_SIZE / 2;\n        laser.y = this.enemyY + BALL_SIZE / 2; // Spawn from enemy's current center Y\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n\n        // Calculate the NEXT spawn position (for the next cycle)\n        laser.nextY = this.generateRandomLaserY();\n      }\n\n      // Check collision with player\n      if (\n        !laser.hit &&\n        playerPosition.x + BALL_SIZE > laser.x &&\n        playerPosition.x < laser.x + LASER_WIDTH &&\n        playerPosition.y + BALL_SIZE > laser.y &&\n        playerPosition.y < laser.y + LASER_HEIGHT\n      ) {\n        laser.hit = true;\n        wasHit = true;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (\n        !laser.scored &&\n        !laser.hit &&\n        playerHasJumped &&\n        playerPosition.x > laser.x + LASER_WIDTH\n      ) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    // Smoothly interpolate enemy Y position every frame\n    // Enemy is always moving toward targetEnemyY\n    const previousY = this.enemyY;\n    this.enemyY += (this.targetEnemyY - this.enemyY) * ENEMY_MOVE_SPEED;\n\n    // Calculate velocity for squash/stretch effect\n    this.enemyVelocity = this.enemyY - previousY;\n\n    return { scoreChange, wasHit };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers(): LaserState[] {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers(): number {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position (smoothly animated)\n   */\n  getEnemyY(): number {\n    return this.enemyY;\n  }\n\n  /**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   */\n  getEnemyScale(): { scaleX: number; scaleY: number } {\n    // Calculate squash/stretch based on velocity\n    // Moving down (positive velocity) = stretch vertically\n    // Moving up (negative velocity) = stretch horizontally\n\n    const velocityFactor = Math.abs(this.enemyVelocity) * 2; // Amplify for visibility\n\n    let scaleX = 1;\n    let scaleY = 1;\n\n    if (Math.abs(this.enemyVelocity) > 0.1) {\n      if (this.enemyVelocity > 0) {\n        // Moving down - stretch vertically, squash horizontally\n        scaleY = 1 + velocityFactor;\n        scaleX = 1 - velocityFactor * 0.5;\n      } else {\n        // Moving up - stretch horizontally, squash vertically\n        scaleX = 1 + velocityFactor;\n        scaleY = 1 - velocityFactor * 0.5;\n      }\n    }\n\n    // Clamp values to reasonable ranges\n    scaleX = Math.max(0.7, Math.min(1.3, scaleX));\n    scaleY = Math.max(0.7, Math.min(1.3, scaleY));\n\n    return { scaleX, scaleY };\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset(): void {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.targetEnemyY = this.centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth: number, screenHeight: number, centerY: number, enemyX: number): void {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyX = enemyX;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}