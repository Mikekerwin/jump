{"ast":null,"code":"/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */\n\nimport { LASER_WIDTH, LASER_HEIGHT, BASE_LASER_SPEED, LASER_SPEED_INCREMENT, MAX_LASERS, SCORE_PER_LASER_UNLOCK, SCORE_PER_SPEED_INCREMENT, SPEED_INCREMENTS_PER_CYCLE, BALL_SIZE, ENEMY_MOVE_SPEED, ENEMY_MOVEMENT_DELAY, ENEMY_SETTLE_THRESHOLD, ENEMY_BOUNCE_AMPLITUDE, ENEMY_OSCILLATION_DAMPING, ENEMY_MIN_OSCILLATION_VELOCITY, CHAOS_INCREMENT_INTERVAL, BASE_LASER_RANDOMNESS, CHAOS_MULTIPLIER_PER_INTERVAL } from '../config/gameConfig';\nimport { ENEMY_WIDTH_GROWTH_PER_CYCLE, ENEMY_HEIGHT_GROWTH_PER_CYCLE } from '../config/gameConfig';\nexport class LaserPhysics {\n  constructor(screenWidth, screenHeight, centerY, enemyX) {\n    this.lasers = [];\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = void 0;\n    this.targetEnemyY = void 0;\n    // Target Y position for smooth movement\n    this.pendingTargetY = null;\n    // Delayed target position\n    this.movementDelayTimer = 0;\n    // Timer for movement delay\n    this.enemyVelocity = 0;\n    // Track movement velocity for squash/stretch\n    this.oscillationVelocity = 0;\n    // Velocity for settling bounce/oscillation\n    this.isSettling = false;\n    // Whether enemy is in settling/oscillation mode\n    this.currentScore = 0;\n    // Track current score for chaos calculation\n    this.laserSpawnCounter = 0;\n    // New: Counter for alternating laser widths\n    this.enemyGrowthLevel = 0;\n    // How many times the enemy has grown\n    this.centerY = void 0;\n    this.minLaserY = void 0;\n    this.enemyX = void 0;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.targetEnemyY = centerY;\n    this.enemyX = enemyX;\n    this.initializeLasers();\n  }\n\n  /**\n   * Sets the current growth level of the enemy.\n   * This is called from the main game loop when the hit counter threshold is met.\n   * @param level The new growth level.\n   */\n  setEnemyGrowthLevel(level) {\n    this.enemyGrowthLevel = level;\n  }\n\n  /**\n   * Determines the width of the next laser to spawn based on an alternating pattern.\n   * This ensures that one laser is normal width, the next is double width, and so on.\n   * This pattern activates when the score is 100 or more.\n   */\n  getNextLaserWidth() {\n    if (this.currentScore >= 100) {\n      // Apply alternating width from score 100\n      return this.laserSpawnCounter++ % 2 === 0 ? LASER_WIDTH : LASER_WIDTH * 2;\n    }\n    return LASER_WIDTH;\n  }\n\n  /**\n   * Generate a random Y position for laser spawn\n   * Chaos increases every 5 points, resets at each 25-point threshold\n   */\n  generateRandomLaserY(score) {\n    // Calculate position within current 25-point cycle (0-24)\n    const scoreInCycle = score % SCORE_PER_LASER_UNLOCK;\n\n    // Calculate how many 5-point intervals we've passed in this cycle\n    const chaosIntervals = Math.floor(scoreInCycle / CHAOS_INCREMENT_INTERVAL);\n\n    // Calculate current chaos multiplier (resets every 25 points)\n    const currentChaos = BASE_LASER_RANDOMNESS + chaosIntervals * CHAOS_MULTIPLIER_PER_INTERVAL;\n\n    // Calculate the range of valid positions\n    const fullRange = this.centerY - this.minLaserY;\n    const randomRange = fullRange * currentChaos;\n    const centerPosition = this.minLaserY + fullRange / 2;\n\n    // Generate random position within chaos-modified range\n    return centerPosition - randomRange / 2 + Math.random() * randomRange;\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  initializeLasers() {\n    const currentEnemyWidth = BALL_SIZE + this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE;\n    const firstLaserY = this.centerY;\n    const nextLaserY = this.generateRandomLaserY(0);\n    this.lasers = [{\n      x: this.enemyX + currentEnemyWidth / 2,\n      // Spawn from enemy center X\n      y: firstLaserY,\n      hit: false,\n      scored: false,\n      passed: false,\n      nextY: nextLaserY,\n      // Pre-calculate next position\n      width: this.getNextLaserWidth() // Use new method for initial width\n    }];\n\n    // Set initial target\n    this.targetEnemyY = firstLaserY;\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score) {\n    this.currentScore = score; // Update score for chaos calculation\n\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reset speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      this.baseSpeed = BASE_LASER_SPEED;\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      const currentEnemyWidth = BALL_SIZE + this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE;\n      const newLaserY = this.generateRandomLaserY(score);\n      // When a new laser is added, ensure its initial width follows the alternating pattern\n      this.lasers.push({\n        x: this.enemyX + currentEnemyWidth / 2,\n        // Spawn from enemy center X\n        y: newLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: this.generateRandomLaserY(score),\n        // Pre-calculate next position\n        width: this.getNextLaserWidth() // Use new method for new lasers\n      });\n    }\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   */\n  getCurrentSpeed(score) {\n    const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT) % SPEED_INCREMENTS_PER_CYCLE;\n    return this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */\n  update(score, playerPosition, playerHasJumped) {\n    this.currentScore = score; // Update score for chaos calculation\n    const currentSpeed = this.getCurrentSpeed(score);\n    let scoreChange = 0;\n    let wasHit = false;\n    this.lasers.forEach(laser => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      const laserWidth = laser.width || LASER_WIDTH;\n      if (laser.x + laserWidth < 0) {\n        const currentEnemyWidth = BALL_SIZE + this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE;\n        const currentEnemyHeight = BALL_SIZE + this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE;\n        // Spawn laser from enemy's current center position\n        laser.x = this.enemyX + currentEnemyWidth / 2;\n        laser.y = this.enemyY + currentEnemyHeight / 2; // Spawn from enemy's current center Y\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n        // Use the new method for respawned lasers to maintain the alternating pattern\n        laser.width = this.getNextLaserWidth();\n        // Calculate the NEXT spawn position with chaos based on current score\n        laser.nextY = this.generateRandomLaserY(this.currentScore);\n\n        // Set up delayed movement to next position\n        this.pendingTargetY = laser.nextY;\n        this.movementDelayTimer = ENEMY_MOVEMENT_DELAY;\n      }\n\n      // Check collision with player (use laser's custom width if set)\n      const currentLaserWidth = laser.width || LASER_WIDTH;\n      if (!laser.hit && playerPosition.x + BALL_SIZE > laser.x && playerPosition.x < laser.x + currentLaserWidth && playerPosition.y + BALL_SIZE > laser.y &&\n      // Player bottom vs laser top\n      playerPosition.y < laser.y + LASER_HEIGHT // Player top vs laser bottom\n      ) {\n        laser.hit = true;\n        wasHit = true;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (!laser.scored && !laser.hit && playerHasJumped && playerPosition.x > laser.x + currentLaserWidth) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    // Handle movement delay timer\n    if (this.movementDelayTimer > 0) {\n      // Countdown the delay timer (assuming ~16.67ms per frame at 60 FPS)\n      this.movementDelayTimer -= 16.67;\n\n      // When delay expires, start moving to the pending target\n      if (this.movementDelayTimer <= 0 && this.pendingTargetY !== null) {\n        this.targetEnemyY = this.pendingTargetY;\n        this.pendingTargetY = null;\n        this.isSettling = false; // Reset settling mode for new movement\n      }\n    }\n    const previousY = this.enemyY;\n    const distanceToTarget = Math.abs(this.targetEnemyY - this.enemyY);\n\n    // Check if we should enter settling/oscillation mode\n    if (distanceToTarget < ENEMY_SETTLE_THRESHOLD && !this.isSettling) {\n      this.isSettling = true;\n      // Give it a strong initial bounce velocity for visible overshoot\n      // Direction depends on which way we're approaching\n      const direction = this.enemyY < this.targetEnemyY ? 1 : -1;\n      this.oscillationVelocity = direction * ENEMY_BOUNCE_AMPLITUDE;\n    }\n    if (this.isSettling) {\n      // Physics-based oscillation (like blue ball bouncing)\n      this.enemyY += this.oscillationVelocity;\n\n      // Check if we've crossed the target (bounce)\n      const crossedTarget = this.oscillationVelocity > 0 && this.enemyY > this.targetEnemyY || this.oscillationVelocity < 0 && this.enemyY < this.targetEnemyY;\n      if (crossedTarget) {\n        // Snap to target and reverse with damping\n        this.enemyY = this.targetEnemyY;\n        this.oscillationVelocity = -this.oscillationVelocity * ENEMY_OSCILLATION_DAMPING;\n      }\n\n      // Stop oscillating when velocity is too small\n      if (Math.abs(this.oscillationVelocity) < ENEMY_MIN_OSCILLATION_VELOCITY) {\n        this.oscillationVelocity = 0;\n        this.enemyY = this.targetEnemyY;\n      }\n    } else {\n      // Normal smooth interpolation when not settling\n      this.enemyY += (this.targetEnemyY - this.enemyY) * ENEMY_MOVE_SPEED;\n    }\n\n    // Calculate velocity for squash/stretch effect\n    this.enemyVelocity = this.enemyY - previousY;\n    return {\n      scoreChange,\n      wasHit\n    };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers() {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers() {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position (smoothly animated)\n   */\n  getEnemyY() {\n    return this.enemyY;\n  }\n\n  /**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   * Squishes in the direction of movement (like blue ball bouncing through liquid)\n   */\n  getEnemyScale() {\n    // Base size including growth\n    const baseWidth = BALL_SIZE + this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE;\n    const baseHeight = BALL_SIZE + this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE;\n\n    // Calculate squash based on velocity\n    // Moving down (positive velocity) = squish vertically, expand horizontally\n    // Moving up (negative velocity) = squish horizontally, expand vertically\n\n    const velocityFactor = Math.abs(this.enemyVelocity) * 2; // Amplify for visibility\n\n    let dynamicScaleX = 1;\n    let dynamicScaleY = 1;\n    if (Math.abs(this.enemyVelocity) > 0.1) {\n      if (this.enemyVelocity > 0) {\n        // Moving down - squish vertically, expand horizontally\n        dynamicScaleY = 1 - velocityFactor * 0.5; // Compress in direction of movement\n        dynamicScaleX = 1 + velocityFactor; // Expand perpendicular to movement\n      } else {\n        // Moving up - squish horizontally, expand vertically\n        dynamicScaleX = 1 - velocityFactor * 0.5; // Compress in direction of movement\n        dynamicScaleY = 1 + velocityFactor; // Expand perpendicular to movement\n      }\n    }\n\n    // Clamp values to reasonable ranges\n    dynamicScaleX = Math.max(0.7, Math.min(1.3, dynamicScaleX));\n    dynamicScaleY = Math.max(0.7, Math.min(1.3, dynamicScaleY));\n\n    // Combine growth scale with dynamic velocity scale\n    // The final scale is (base size + growth) / base size * dynamic scale\n    const growthScaleX = baseWidth / BALL_SIZE;\n    const growthScaleY = baseHeight / BALL_SIZE;\n\n    // Combine growth with the dynamic squash/stretch effect.\n    // The growth scale acts as the new \"base\" size, and the dynamic\n    // scale modifies that.\n    const finalScaleX = growthScaleX;\n    const finalScaleY = growthScaleY;\n    return {\n      scaleX: finalScaleX,\n      scaleY: finalScaleY\n    };\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset() {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.targetEnemyY = this.centerY;\n    this.laserSpawnCounter = 0; // Reset counter on game restart\n    this.enemyGrowthLevel = 0; // Reset growth on game restart\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth, screenHeight, centerY, enemyX) {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyX = enemyX;\n  }\n}","map":{"version":3,"names":["LASER_WIDTH","LASER_HEIGHT","BASE_LASER_SPEED","LASER_SPEED_INCREMENT","MAX_LASERS","SCORE_PER_LASER_UNLOCK","SCORE_PER_SPEED_INCREMENT","SPEED_INCREMENTS_PER_CYCLE","BALL_SIZE","ENEMY_MOVE_SPEED","ENEMY_MOVEMENT_DELAY","ENEMY_SETTLE_THRESHOLD","ENEMY_BOUNCE_AMPLITUDE","ENEMY_OSCILLATION_DAMPING","ENEMY_MIN_OSCILLATION_VELOCITY","CHAOS_INCREMENT_INTERVAL","BASE_LASER_RANDOMNESS","CHAOS_MULTIPLIER_PER_INTERVAL","ENEMY_WIDTH_GROWTH_PER_CYCLE","ENEMY_HEIGHT_GROWTH_PER_CYCLE","LaserPhysics","constructor","screenWidth","screenHeight","centerY","enemyX","lasers","numLasers","baseSpeed","enemyY","targetEnemyY","pendingTargetY","movementDelayTimer","enemyVelocity","oscillationVelocity","isSettling","currentScore","laserSpawnCounter","enemyGrowthLevel","minLaserY","initializeLasers","setEnemyGrowthLevel","level","getNextLaserWidth","generateRandomLaserY","score","scoreInCycle","chaosIntervals","Math","floor","currentChaos","fullRange","randomRange","centerPosition","random","currentEnemyWidth","firstLaserY","nextLaserY","x","y","hit","scored","passed","nextY","width","updateLaserCount","extraLasers","prevNumLasers","min","length","newLaserY","push","pop","getCurrentSpeed","speedIncrements","update","playerPosition","playerHasJumped","currentSpeed","scoreChange","wasHit","forEach","laser","laserWidth","currentEnemyHeight","currentLaserWidth","previousY","distanceToTarget","abs","direction","crossedTarget","getLasers","getNumLasers","getEnemyY","getEnemyScale","baseWidth","baseHeight","velocityFactor","dynamicScaleX","dynamicScaleY","max","growthScaleX","growthScaleY","finalScaleX","finalScaleY","scaleX","scaleY","reset","updateDimensions"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/laserPhysics.ts"],"sourcesContent":["/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */\n\nimport { LaserState, Position } from '../types/game';\nimport {\n  LASER_WIDTH,\n  LASER_HEIGHT,\n  BASE_LASER_SPEED,\n  LASER_SPEED_INCREMENT,\n  MAX_LASERS,\n  SCORE_PER_LASER_UNLOCK,\n  SCORE_PER_SPEED_INCREMENT,\n  SPEED_INCREMENTS_PER_CYCLE,\n  BALL_SIZE,\n  ENEMY_MOVE_SPEED,\n  ENEMY_MOVEMENT_DELAY,\n  ENEMY_SETTLE_THRESHOLD,\n  ENEMY_BOUNCE_AMPLITUDE,\n  ENEMY_OSCILLATION_DAMPING,\n  ENEMY_MIN_OSCILLATION_VELOCITY,\n  CHAOS_INCREMENT_INTERVAL,\n  BASE_LASER_RANDOMNESS,\n  CHAOS_MULTIPLIER_PER_INTERVAL,\n} from '../config/gameConfig';\nimport {\n  ENEMY_WIDTH_GROWTH_PER_CYCLE,\n  ENEMY_HEIGHT_GROWTH_PER_CYCLE,\n} from '../config/gameConfig';\n\nexport class LaserPhysics {\n  private lasers: LaserState[] = [];\n  private numLasers: number = 1;\n  private baseSpeed: number = BASE_LASER_SPEED;\n  private enemyY: number;\n  private targetEnemyY: number; // Target Y position for smooth movement\n  private pendingTargetY: number | null = null; // Delayed target position\n  private movementDelayTimer: number = 0; // Timer for movement delay\n  private enemyVelocity: number = 0; // Track movement velocity for squash/stretch\n  private oscillationVelocity: number = 0; // Velocity for settling bounce/oscillation\n  private isSettling: boolean = false; // Whether enemy is in settling/oscillation mode\n  private currentScore: number = 0; // Track current score for chaos calculation\n  private laserSpawnCounter: number = 0; // New: Counter for alternating laser widths\n  private enemyGrowthLevel: number = 0; // How many times the enemy has grown\n  private centerY: number;\n  private minLaserY: number;\n  private enemyX: number;\n\n  constructor(screenWidth: number, screenHeight: number, centerY: number, enemyX: number) {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.targetEnemyY = centerY;\n    this.enemyX = enemyX;\n    this.initializeLasers();\n  }\n\n  /**\n   * Sets the current growth level of the enemy.\n   * This is called from the main game loop when the hit counter threshold is met.\n   * @param level The new growth level.\n   */\n  setEnemyGrowthLevel(level: number): void {\n    this.enemyGrowthLevel = level;\n  }\n\n  /**\n   * Determines the width of the next laser to spawn based on an alternating pattern.\n   * This ensures that one laser is normal width, the next is double width, and so on.\n   * This pattern activates when the score is 100 or more.\n   */\n  private getNextLaserWidth(): number {\n    if (this.currentScore >= 100) { // Apply alternating width from score 100\n      return (this.laserSpawnCounter++ % 2 === 0) ? LASER_WIDTH : LASER_WIDTH * 2;\n    }\n    return LASER_WIDTH;\n  }\n\n  /**\n   * Generate a random Y position for laser spawn\n   * Chaos increases every 5 points, resets at each 25-point threshold\n   */\n  private generateRandomLaserY(score: number): number {\n    // Calculate position within current 25-point cycle (0-24)\n    const scoreInCycle = score % SCORE_PER_LASER_UNLOCK;\n\n    // Calculate how many 5-point intervals we've passed in this cycle\n    const chaosIntervals = Math.floor(scoreInCycle / CHAOS_INCREMENT_INTERVAL);\n\n    // Calculate current chaos multiplier (resets every 25 points)\n    const currentChaos = BASE_LASER_RANDOMNESS + (chaosIntervals * CHAOS_MULTIPLIER_PER_INTERVAL);\n\n    // Calculate the range of valid positions\n    const fullRange = this.centerY - this.minLaserY;\n    const randomRange = fullRange * currentChaos;\n    const centerPosition = this.minLaserY + (fullRange / 2);\n\n    // Generate random position within chaos-modified range\n    return centerPosition - (randomRange / 2) + (Math.random() * randomRange);\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  private initializeLasers(): void {\n    const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n    const firstLaserY = this.centerY;\n    const nextLaserY = this.generateRandomLaserY(0);\n\n    this.lasers = [\n      {\n        x: this.enemyX + currentEnemyWidth / 2, // Spawn from enemy center X\n        y: firstLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: nextLaserY, // Pre-calculate next position\n        width: this.getNextLaserWidth(), // Use new method for initial width\n      },\n    ];\n\n    // Set initial target\n    this.targetEnemyY = firstLaserY;\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score: number): void {\n    this.currentScore = score; // Update score for chaos calculation\n\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reset speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      this.baseSpeed = BASE_LASER_SPEED;\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n      const newLaserY = this.generateRandomLaserY(score);\n      // When a new laser is added, ensure its initial width follows the alternating pattern\n      this.lasers.push({\n        x: this.enemyX + currentEnemyWidth / 2, // Spawn from enemy center X\n        y: newLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: this.generateRandomLaserY(score), // Pre-calculate next position\n        width: this.getNextLaserWidth(), // Use new method for new lasers\n      });\n    }\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   */\n  private getCurrentSpeed(score: number): number {\n    const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT) % SPEED_INCREMENTS_PER_CYCLE;\n    return this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */\n  update(\n    score: number,\n    playerPosition: Position,\n    playerHasJumped: boolean\n  ): { scoreChange: number; wasHit: boolean } {\n    this.currentScore = score; // Update score for chaos calculation\n    const currentSpeed = this.getCurrentSpeed(score);\n    let scoreChange = 0;\n    let wasHit = false;\n\n    this.lasers.forEach((laser) => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      const laserWidth = laser.width || LASER_WIDTH;\n      if (laser.x + laserWidth < 0) {\n        const currentEnemyWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n        const currentEnemyHeight = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE);\n        // Spawn laser from enemy's current center position\n        laser.x = this.enemyX + currentEnemyWidth / 2;\n        laser.y = this.enemyY + currentEnemyHeight / 2; // Spawn from enemy's current center Y\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n        // Use the new method for respawned lasers to maintain the alternating pattern\n        laser.width = this.getNextLaserWidth();\n        // Calculate the NEXT spawn position with chaos based on current score\n        laser.nextY = this.generateRandomLaserY(this.currentScore);\n\n        // Set up delayed movement to next position\n        this.pendingTargetY = laser.nextY;\n        this.movementDelayTimer = ENEMY_MOVEMENT_DELAY;\n      }\n\n      // Check collision with player (use laser's custom width if set)\n      const currentLaserWidth = laser.width || LASER_WIDTH;\n      if (\n        !laser.hit &&\n        playerPosition.x + BALL_SIZE > laser.x &&\n        playerPosition.x < laser.x + currentLaserWidth &&\n        playerPosition.y + BALL_SIZE > laser.y && // Player bottom vs laser top\n        playerPosition.y < laser.y + LASER_HEIGHT // Player top vs laser bottom\n      ) {\n        laser.hit = true;\n        wasHit = true;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (\n        !laser.scored &&\n        !laser.hit &&\n        playerHasJumped &&\n        playerPosition.x > laser.x + currentLaserWidth\n      ) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    // Handle movement delay timer\n    if (this.movementDelayTimer > 0) {\n      // Countdown the delay timer (assuming ~16.67ms per frame at 60 FPS)\n      this.movementDelayTimer -= 16.67;\n\n      // When delay expires, start moving to the pending target\n      if (this.movementDelayTimer <= 0 && this.pendingTargetY !== null) {\n        this.targetEnemyY = this.pendingTargetY;\n        this.pendingTargetY = null;\n        this.isSettling = false; // Reset settling mode for new movement\n      }\n    }\n\n    const previousY = this.enemyY;\n    const distanceToTarget = Math.abs(this.targetEnemyY - this.enemyY);\n\n    // Check if we should enter settling/oscillation mode\n    if (distanceToTarget < ENEMY_SETTLE_THRESHOLD && !this.isSettling) {\n      this.isSettling = true;\n      // Give it a strong initial bounce velocity for visible overshoot\n      // Direction depends on which way we're approaching\n      const direction = this.enemyY < this.targetEnemyY ? 1 : -1;\n      this.oscillationVelocity = direction * ENEMY_BOUNCE_AMPLITUDE;\n    }\n\n    if (this.isSettling) {\n      // Physics-based oscillation (like blue ball bouncing)\n      this.enemyY += this.oscillationVelocity;\n\n      // Check if we've crossed the target (bounce)\n      const crossedTarget =\n        (this.oscillationVelocity > 0 && this.enemyY > this.targetEnemyY) ||\n        (this.oscillationVelocity < 0 && this.enemyY < this.targetEnemyY);\n\n      if (crossedTarget) {\n        // Snap to target and reverse with damping\n        this.enemyY = this.targetEnemyY;\n        this.oscillationVelocity = -this.oscillationVelocity * ENEMY_OSCILLATION_DAMPING;\n      }\n\n      // Stop oscillating when velocity is too small\n      if (Math.abs(this.oscillationVelocity) < ENEMY_MIN_OSCILLATION_VELOCITY) {\n        this.oscillationVelocity = 0;\n        this.enemyY = this.targetEnemyY;\n      }\n    } else {\n      // Normal smooth interpolation when not settling\n      this.enemyY += (this.targetEnemyY - this.enemyY) * ENEMY_MOVE_SPEED;\n    }\n\n    // Calculate velocity for squash/stretch effect\n    this.enemyVelocity = this.enemyY - previousY;\n\n    return { scoreChange, wasHit };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers(): LaserState[] {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers(): number {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position (smoothly animated)\n   */\n  getEnemyY(): number {\n    return this.enemyY;\n  }\n\n  /**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   * Squishes in the direction of movement (like blue ball bouncing through liquid)\n   */\n  getEnemyScale(): { scaleX: number; scaleY: number } {\n    // Base size including growth\n    const baseWidth = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_WIDTH_GROWTH_PER_CYCLE);\n    const baseHeight = BALL_SIZE + (this.enemyGrowthLevel * ENEMY_HEIGHT_GROWTH_PER_CYCLE);\n\n    // Calculate squash based on velocity\n    // Moving down (positive velocity) = squish vertically, expand horizontally\n    // Moving up (negative velocity) = squish horizontally, expand vertically\n\n    const velocityFactor = Math.abs(this.enemyVelocity) * 2; // Amplify for visibility\n\n    let dynamicScaleX = 1;\n    let dynamicScaleY = 1;\n\n    if (Math.abs(this.enemyVelocity) > 0.1) {\n      if (this.enemyVelocity > 0) {\n        // Moving down - squish vertically, expand horizontally\n        dynamicScaleY = 1 - velocityFactor * 0.5; // Compress in direction of movement\n        dynamicScaleX = 1 + velocityFactor; // Expand perpendicular to movement\n      } else {\n        // Moving up - squish horizontally, expand vertically\n        dynamicScaleX = 1 - velocityFactor * 0.5; // Compress in direction of movement\n        dynamicScaleY = 1 + velocityFactor; // Expand perpendicular to movement\n      }\n    }\n\n    // Clamp values to reasonable ranges\n    dynamicScaleX = Math.max(0.7, Math.min(1.3, dynamicScaleX));\n    dynamicScaleY = Math.max(0.7, Math.min(1.3, dynamicScaleY));\n\n    // Combine growth scale with dynamic velocity scale\n    // The final scale is (base size + growth) / base size * dynamic scale\n    const growthScaleX = baseWidth / BALL_SIZE;\n    const growthScaleY = baseHeight / BALL_SIZE;\n\n    // Combine growth with the dynamic squash/stretch effect.\n    // The growth scale acts as the new \"base\" size, and the dynamic\n    // scale modifies that.\n    const finalScaleX = growthScaleX;\n    const finalScaleY = growthScaleY;\n\n    return { scaleX: finalScaleX, scaleY: finalScaleY };\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset(): void {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.targetEnemyY = this.centerY;\n    this.laserSpawnCounter = 0; // Reset counter on game restart\n    this.enemyGrowthLevel = 0; // Reset growth on game restart\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth: number, screenHeight: number, centerY: number, enemyX: number): void {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyX = enemyX;\n  }\n}\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;;AAGA,SACEA,WAAW,EACXC,YAAY,EACZC,gBAAgB,EAChBC,qBAAqB,EACrBC,UAAU,EACVC,sBAAsB,EACtBC,yBAAyB,EACzBC,0BAA0B,EAC1BC,SAAS,EACTC,gBAAgB,EAChBC,oBAAoB,EACpBC,sBAAsB,EACtBC,sBAAsB,EACtBC,yBAAyB,EACzBC,8BAA8B,EAC9BC,wBAAwB,EACxBC,qBAAqB,EACrBC,6BAA6B,QACxB,sBAAsB;AAC7B,SACEC,4BAA4B,EAC5BC,6BAA6B,QACxB,sBAAsB;AAE7B,OAAO,MAAMC,YAAY,CAAC;EAkBxBC,WAAWA,CAACC,WAAmB,EAAEC,YAAoB,EAAEC,OAAe,EAAEC,MAAc,EAAE;IAAA,KAjBhFC,MAAM,GAAiB,EAAE;IAAA,KACzBC,SAAS,GAAW,CAAC;IAAA,KACrBC,SAAS,GAAW1B,gBAAgB;IAAA,KACpC2B,MAAM;IAAA,KACNC,YAAY;IAAU;IAAA,KACtBC,cAAc,GAAkB,IAAI;IAAE;IAAA,KACtCC,kBAAkB,GAAW,CAAC;IAAE;IAAA,KAChCC,aAAa,GAAW,CAAC;IAAE;IAAA,KAC3BC,mBAAmB,GAAW,CAAC;IAAE;IAAA,KACjCC,UAAU,GAAY,KAAK;IAAE;IAAA,KAC7BC,YAAY,GAAW,CAAC;IAAE;IAAA,KAC1BC,iBAAiB,GAAW,CAAC;IAAE;IAAA,KAC/BC,gBAAgB,GAAW,CAAC;IAAE;IAAA,KAC9Bd,OAAO;IAAA,KACPe,SAAS;IAAA,KACTd,MAAM;IAGZ,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACe,SAAS,GAAGhB,YAAY,GAAG,GAAG;IACnC,IAAI,CAACM,MAAM,GAAGL,OAAO;IACrB,IAAI,CAACM,YAAY,GAAGN,OAAO;IAC3B,IAAI,CAACC,MAAM,GAAGA,MAAM;IACpB,IAAI,CAACe,gBAAgB,CAAC,CAAC;EACzB;;EAEA;AACF;AACA;AACA;AACA;EACEC,mBAAmBA,CAACC,KAAa,EAAQ;IACvC,IAAI,CAACJ,gBAAgB,GAAGI,KAAK;EAC/B;;EAEA;AACF;AACA;AACA;AACA;EACUC,iBAAiBA,CAAA,EAAW;IAClC,IAAI,IAAI,CAACP,YAAY,IAAI,GAAG,EAAE;MAAE;MAC9B,OAAQ,IAAI,CAACC,iBAAiB,EAAE,GAAG,CAAC,KAAK,CAAC,GAAIrC,WAAW,GAAGA,WAAW,GAAG,CAAC;IAC7E;IACA,OAAOA,WAAW;EACpB;;EAEA;AACF;AACA;AACA;EACU4C,oBAAoBA,CAACC,KAAa,EAAU;IAClD;IACA,MAAMC,YAAY,GAAGD,KAAK,GAAGxC,sBAAsB;;IAEnD;IACA,MAAM0C,cAAc,GAAGC,IAAI,CAACC,KAAK,CAACH,YAAY,GAAG/B,wBAAwB,CAAC;;IAE1E;IACA,MAAMmC,YAAY,GAAGlC,qBAAqB,GAAI+B,cAAc,GAAG9B,6BAA8B;;IAE7F;IACA,MAAMkC,SAAS,GAAG,IAAI,CAAC3B,OAAO,GAAG,IAAI,CAACe,SAAS;IAC/C,MAAMa,WAAW,GAAGD,SAAS,GAAGD,YAAY;IAC5C,MAAMG,cAAc,GAAG,IAAI,CAACd,SAAS,GAAIY,SAAS,GAAG,CAAE;;IAEvD;IACA,OAAOE,cAAc,GAAID,WAAW,GAAG,CAAE,GAAIJ,IAAI,CAACM,MAAM,CAAC,CAAC,GAAGF,WAAY;EAC3E;;EAEA;AACF;AACA;EACUZ,gBAAgBA,CAAA,EAAS;IAC/B,MAAMe,iBAAiB,GAAG/C,SAAS,GAAI,IAAI,CAAC8B,gBAAgB,GAAGpB,4BAA6B;IAC5F,MAAMsC,WAAW,GAAG,IAAI,CAAChC,OAAO;IAChC,MAAMiC,UAAU,GAAG,IAAI,CAACb,oBAAoB,CAAC,CAAC,CAAC;IAE/C,IAAI,CAAClB,MAAM,GAAG,CACZ;MACEgC,CAAC,EAAE,IAAI,CAACjC,MAAM,GAAG8B,iBAAiB,GAAG,CAAC;MAAE;MACxCI,CAAC,EAAEH,WAAW;MACdI,GAAG,EAAE,KAAK;MACVC,MAAM,EAAE,KAAK;MACbC,MAAM,EAAE,KAAK;MACbC,KAAK,EAAEN,UAAU;MAAE;MACnBO,KAAK,EAAE,IAAI,CAACrB,iBAAiB,CAAC,CAAC,CAAE;IACnC,CAAC,CACF;;IAED;IACA,IAAI,CAACb,YAAY,GAAG0B,WAAW;EACjC;;EAEA;AACF;AACA;EACES,gBAAgBA,CAACpB,KAAa,EAAQ;IACpC,IAAI,CAACT,YAAY,GAAGS,KAAK,CAAC,CAAC;;IAE3B,MAAMqB,WAAW,GAAGlB,IAAI,CAACC,KAAK,CAACJ,KAAK,GAAGxC,sBAAsB,CAAC;IAC9D,MAAM8D,aAAa,GAAG,IAAI,CAACxC,SAAS;IACpC,IAAI,CAACA,SAAS,GAAGqB,IAAI,CAACoB,GAAG,CAACF,WAAW,GAAG,CAAC,EAAE9D,UAAU,CAAC;;IAEtD;IACA,IAAI,IAAI,CAACuB,SAAS,GAAGwC,aAAa,EAAE;MAClC,IAAI,CAACvC,SAAS,GAAG1B,gBAAgB;IACnC;;IAEA;IACA,OAAO,IAAI,CAACwB,MAAM,CAAC2C,MAAM,GAAG,IAAI,CAAC1C,SAAS,EAAE;MAC1C,MAAM4B,iBAAiB,GAAG/C,SAAS,GAAI,IAAI,CAAC8B,gBAAgB,GAAGpB,4BAA6B;MAC5F,MAAMoD,SAAS,GAAG,IAAI,CAAC1B,oBAAoB,CAACC,KAAK,CAAC;MAClD;MACA,IAAI,CAACnB,MAAM,CAAC6C,IAAI,CAAC;QACfb,CAAC,EAAE,IAAI,CAACjC,MAAM,GAAG8B,iBAAiB,GAAG,CAAC;QAAE;QACxCI,CAAC,EAAEW,SAAS;QACZV,GAAG,EAAE,KAAK;QACVC,MAAM,EAAE,KAAK;QACbC,MAAM,EAAE,KAAK;QACbC,KAAK,EAAE,IAAI,CAACnB,oBAAoB,CAACC,KAAK,CAAC;QAAE;QACzCmB,KAAK,EAAE,IAAI,CAACrB,iBAAiB,CAAC,CAAC,CAAE;MACnC,CAAC,CAAC;IACJ;IACA,OAAO,IAAI,CAACjB,MAAM,CAAC2C,MAAM,GAAG,IAAI,CAAC1C,SAAS,EAAE;MAC1C,IAAI,CAACD,MAAM,CAAC8C,GAAG,CAAC,CAAC;IACnB;EACF;;EAEA;AACF;AACA;EACUC,eAAeA,CAAC5B,KAAa,EAAU;IAC7C,MAAM6B,eAAe,GAAG1B,IAAI,CAACC,KAAK,CAACJ,KAAK,GAAGvC,yBAAyB,CAAC,GAAGC,0BAA0B;IAClG,OAAO,IAAI,CAACqB,SAAS,GAAGzB,qBAAqB,GAAGuE,eAAe;EACjE;;EAEA;AACF;AACA;AACA;EACEC,MAAMA,CACJ9B,KAAa,EACb+B,cAAwB,EACxBC,eAAwB,EACkB;IAC1C,IAAI,CAACzC,YAAY,GAAGS,KAAK,CAAC,CAAC;IAC3B,MAAMiC,YAAY,GAAG,IAAI,CAACL,eAAe,CAAC5B,KAAK,CAAC;IAChD,IAAIkC,WAAW,GAAG,CAAC;IACnB,IAAIC,MAAM,GAAG,KAAK;IAElB,IAAI,CAACtD,MAAM,CAACuD,OAAO,CAAEC,KAAK,IAAK;MAC7B;MACAA,KAAK,CAACxB,CAAC,IAAIoB,YAAY;;MAEvB;MACA,IAAI,CAACI,KAAK,CAACtB,GAAG,IAAI,CAACsB,KAAK,CAACpB,MAAM,IAAIc,cAAc,CAAClB,CAAC,GAAGwB,KAAK,CAACxB,CAAC,GAAG1D,WAAW,EAAE;QAC3EkF,KAAK,CAACpB,MAAM,GAAG,IAAI;QACnB,IAAI,CAACe,eAAe,EAAE;UACpBE,WAAW,IAAI,CAAC;QAClB;MACF;;MAEA;MACA,MAAMI,UAAU,GAAGD,KAAK,CAAClB,KAAK,IAAIhE,WAAW;MAC7C,IAAIkF,KAAK,CAACxB,CAAC,GAAGyB,UAAU,GAAG,CAAC,EAAE;QAC5B,MAAM5B,iBAAiB,GAAG/C,SAAS,GAAI,IAAI,CAAC8B,gBAAgB,GAAGpB,4BAA6B;QAC5F,MAAMkE,kBAAkB,GAAG5E,SAAS,GAAI,IAAI,CAAC8B,gBAAgB,GAAGnB,6BAA8B;QAC9F;QACA+D,KAAK,CAACxB,CAAC,GAAG,IAAI,CAACjC,MAAM,GAAG8B,iBAAiB,GAAG,CAAC;QAC7C2B,KAAK,CAACvB,CAAC,GAAG,IAAI,CAAC9B,MAAM,GAAGuD,kBAAkB,GAAG,CAAC,CAAC,CAAC;QAChDF,KAAK,CAACtB,GAAG,GAAG,KAAK;QACjBsB,KAAK,CAACrB,MAAM,GAAG,KAAK;QACpBqB,KAAK,CAACpB,MAAM,GAAG,KAAK;QACpB;QACAoB,KAAK,CAAClB,KAAK,GAAG,IAAI,CAACrB,iBAAiB,CAAC,CAAC;QACtC;QACAuC,KAAK,CAACnB,KAAK,GAAG,IAAI,CAACnB,oBAAoB,CAAC,IAAI,CAACR,YAAY,CAAC;;QAE1D;QACA,IAAI,CAACL,cAAc,GAAGmD,KAAK,CAACnB,KAAK;QACjC,IAAI,CAAC/B,kBAAkB,GAAGtB,oBAAoB;MAChD;;MAEA;MACA,MAAM2E,iBAAiB,GAAGH,KAAK,CAAClB,KAAK,IAAIhE,WAAW;MACpD,IACE,CAACkF,KAAK,CAACtB,GAAG,IACVgB,cAAc,CAAClB,CAAC,GAAGlD,SAAS,GAAG0E,KAAK,CAACxB,CAAC,IACtCkB,cAAc,CAAClB,CAAC,GAAGwB,KAAK,CAACxB,CAAC,GAAG2B,iBAAiB,IAC9CT,cAAc,CAACjB,CAAC,GAAGnD,SAAS,GAAG0E,KAAK,CAACvB,CAAC;MAAI;MAC1CiB,cAAc,CAACjB,CAAC,GAAGuB,KAAK,CAACvB,CAAC,GAAG1D,YAAY,CAAC;MAAA,EAC1C;QACAiF,KAAK,CAACtB,GAAG,GAAG,IAAI;QAChBoB,MAAM,GAAG,IAAI;MACf;;MAEA;MACA,IACE,CAACE,KAAK,CAACrB,MAAM,IACb,CAACqB,KAAK,CAACtB,GAAG,IACViB,eAAe,IACfD,cAAc,CAAClB,CAAC,GAAGwB,KAAK,CAACxB,CAAC,GAAG2B,iBAAiB,EAC9C;QACAH,KAAK,CAACrB,MAAM,GAAG,IAAI;QACnBkB,WAAW,IAAI,CAAC;MAClB;IACF,CAAC,CAAC;;IAEF;IACA,IAAI,IAAI,CAAC/C,kBAAkB,GAAG,CAAC,EAAE;MAC/B;MACA,IAAI,CAACA,kBAAkB,IAAI,KAAK;;MAEhC;MACA,IAAI,IAAI,CAACA,kBAAkB,IAAI,CAAC,IAAI,IAAI,CAACD,cAAc,KAAK,IAAI,EAAE;QAChE,IAAI,CAACD,YAAY,GAAG,IAAI,CAACC,cAAc;QACvC,IAAI,CAACA,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACI,UAAU,GAAG,KAAK,CAAC,CAAC;MAC3B;IACF;IAEA,MAAMmD,SAAS,GAAG,IAAI,CAACzD,MAAM;IAC7B,MAAM0D,gBAAgB,GAAGvC,IAAI,CAACwC,GAAG,CAAC,IAAI,CAAC1D,YAAY,GAAG,IAAI,CAACD,MAAM,CAAC;;IAElE;IACA,IAAI0D,gBAAgB,GAAG5E,sBAAsB,IAAI,CAAC,IAAI,CAACwB,UAAU,EAAE;MACjE,IAAI,CAACA,UAAU,GAAG,IAAI;MACtB;MACA;MACA,MAAMsD,SAAS,GAAG,IAAI,CAAC5D,MAAM,GAAG,IAAI,CAACC,YAAY,GAAG,CAAC,GAAG,CAAC,CAAC;MAC1D,IAAI,CAACI,mBAAmB,GAAGuD,SAAS,GAAG7E,sBAAsB;IAC/D;IAEA,IAAI,IAAI,CAACuB,UAAU,EAAE;MACnB;MACA,IAAI,CAACN,MAAM,IAAI,IAAI,CAACK,mBAAmB;;MAEvC;MACA,MAAMwD,aAAa,GAChB,IAAI,CAACxD,mBAAmB,GAAG,CAAC,IAAI,IAAI,CAACL,MAAM,GAAG,IAAI,CAACC,YAAY,IAC/D,IAAI,CAACI,mBAAmB,GAAG,CAAC,IAAI,IAAI,CAACL,MAAM,GAAG,IAAI,CAACC,YAAa;MAEnE,IAAI4D,aAAa,EAAE;QACjB;QACA,IAAI,CAAC7D,MAAM,GAAG,IAAI,CAACC,YAAY;QAC/B,IAAI,CAACI,mBAAmB,GAAG,CAAC,IAAI,CAACA,mBAAmB,GAAGrB,yBAAyB;MAClF;;MAEA;MACA,IAAImC,IAAI,CAACwC,GAAG,CAAC,IAAI,CAACtD,mBAAmB,CAAC,GAAGpB,8BAA8B,EAAE;QACvE,IAAI,CAACoB,mBAAmB,GAAG,CAAC;QAC5B,IAAI,CAACL,MAAM,GAAG,IAAI,CAACC,YAAY;MACjC;IACF,CAAC,MAAM;MACL;MACA,IAAI,CAACD,MAAM,IAAI,CAAC,IAAI,CAACC,YAAY,GAAG,IAAI,CAACD,MAAM,IAAIpB,gBAAgB;IACrE;;IAEA;IACA,IAAI,CAACwB,aAAa,GAAG,IAAI,CAACJ,MAAM,GAAGyD,SAAS;IAE5C,OAAO;MAAEP,WAAW;MAAEC;IAAO,CAAC;EAChC;;EAEA;AACF;AACA;EACEW,SAASA,CAAA,EAAiB;IACxB,OAAO,IAAI,CAACjE,MAAM;EACpB;;EAEA;AACF;AACA;EACEkE,YAAYA,CAAA,EAAW;IACrB,OAAO,IAAI,CAACjE,SAAS;EACvB;;EAEA;AACF;AACA;EACEkE,SAASA,CAAA,EAAW;IAClB,OAAO,IAAI,CAAChE,MAAM;EACpB;;EAEA;AACF;AACA;AACA;AACA;EACEiE,aAAaA,CAAA,EAAuC;IAClD;IACA,MAAMC,SAAS,GAAGvF,SAAS,GAAI,IAAI,CAAC8B,gBAAgB,GAAGpB,4BAA6B;IACpF,MAAM8E,UAAU,GAAGxF,SAAS,GAAI,IAAI,CAAC8B,gBAAgB,GAAGnB,6BAA8B;;IAEtF;IACA;IACA;;IAEA,MAAM8E,cAAc,GAAGjD,IAAI,CAACwC,GAAG,CAAC,IAAI,CAACvD,aAAa,CAAC,GAAG,CAAC,CAAC,CAAC;;IAEzD,IAAIiE,aAAa,GAAG,CAAC;IACrB,IAAIC,aAAa,GAAG,CAAC;IAErB,IAAInD,IAAI,CAACwC,GAAG,CAAC,IAAI,CAACvD,aAAa,CAAC,GAAG,GAAG,EAAE;MACtC,IAAI,IAAI,CAACA,aAAa,GAAG,CAAC,EAAE;QAC1B;QACAkE,aAAa,GAAG,CAAC,GAAGF,cAAc,GAAG,GAAG,CAAC,CAAC;QAC1CC,aAAa,GAAG,CAAC,GAAGD,cAAc,CAAC,CAAC;MACtC,CAAC,MAAM;QACL;QACAC,aAAa,GAAG,CAAC,GAAGD,cAAc,GAAG,GAAG,CAAC,CAAC;QAC1CE,aAAa,GAAG,CAAC,GAAGF,cAAc,CAAC,CAAC;MACtC;IACF;;IAEA;IACAC,aAAa,GAAGlD,IAAI,CAACoD,GAAG,CAAC,GAAG,EAAEpD,IAAI,CAACoB,GAAG,CAAC,GAAG,EAAE8B,aAAa,CAAC,CAAC;IAC3DC,aAAa,GAAGnD,IAAI,CAACoD,GAAG,CAAC,GAAG,EAAEpD,IAAI,CAACoB,GAAG,CAAC,GAAG,EAAE+B,aAAa,CAAC,CAAC;;IAE3D;IACA;IACA,MAAME,YAAY,GAAGN,SAAS,GAAGvF,SAAS;IAC1C,MAAM8F,YAAY,GAAGN,UAAU,GAAGxF,SAAS;;IAE3C;IACA;IACA;IACA,MAAM+F,WAAW,GAAGF,YAAY;IAChC,MAAMG,WAAW,GAAGF,YAAY;IAEhC,OAAO;MAAEG,MAAM,EAAEF,WAAW;MAAEG,MAAM,EAAEF;IAAY,CAAC;EACrD;;EAEA;AACF;AACA;EACEG,KAAKA,CAAA,EAAS;IACZ,IAAI,CAAChF,SAAS,GAAG,CAAC;IAClB,IAAI,CAACC,SAAS,GAAG1B,gBAAgB;IACjC,IAAI,CAAC2B,MAAM,GAAG,IAAI,CAACL,OAAO;IAC1B,IAAI,CAACM,YAAY,GAAG,IAAI,CAACN,OAAO;IAChC,IAAI,CAACa,iBAAiB,GAAG,CAAC,CAAC,CAAC;IAC5B,IAAI,CAACC,gBAAgB,GAAG,CAAC,CAAC,CAAC;IAC3B,IAAI,CAACE,gBAAgB,CAAC,CAAC;EACzB;;EAEA;AACF;AACA;EACEoE,gBAAgBA,CAACtF,WAAmB,EAAEC,YAAoB,EAAEC,OAAe,EAAEC,MAAc,EAAQ;IACjG,IAAI,CAACD,OAAO,GAAGA,OAAO;IACtB,IAAI,CAACe,SAAS,GAAGhB,YAAY,GAAG,GAAG;IACnC,IAAI,CAACE,MAAM,GAAGA,MAAM;EACtB;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}