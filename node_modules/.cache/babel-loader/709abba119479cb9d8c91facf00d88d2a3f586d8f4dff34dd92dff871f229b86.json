{"ast":null,"code":"/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */\n\nimport { LASER_WIDTH, LASER_HEIGHT, BASE_LASER_SPEED, LASER_SPEED_INCREMENT, MAX_LASERS, SCORE_PER_LASER_UNLOCK, SCORE_PER_SPEED_INCREMENT, SPEED_INCREMENTS_PER_CYCLE, BALL_SIZE, ENEMY_MOVE_SPEED } from '../config/gameConfig';\nexport class LaserPhysics {\n  constructor(screenWidth, screenHeight, centerY, enemyX) {\n    this.lasers = [];\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = void 0;\n    this.targetEnemyY = void 0;\n    // Target Y position for smooth movement\n    this.enemyVelocity = 0;\n    // Track movement velocity for squash/stretch\n    this.centerY = void 0;\n    this.minLaserY = void 0;\n    this.enemyX = void 0;\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.targetEnemyY = centerY;\n    this.enemyX = enemyX;\n    this.initializeLasers();\n  }\n\n  /**\n   * Generate a random Y position for laser spawn\n   * Adjusted to account for ball size so laser comes from center\n   */\n  generateRandomLaserY() {\n    return Math.random() * (this.centerY - this.minLaserY) + this.minLaserY;\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  initializeLasers() {\n    const firstLaserY = this.centerY;\n    const nextLaserY = this.generateRandomLaserY();\n    this.lasers = [{\n      x: this.enemyX + BALL_SIZE / 2,\n      // Spawn from enemy center X\n      y: firstLaserY,\n      hit: false,\n      scored: false,\n      passed: false,\n      nextY: nextLaserY // Pre-calculate next position\n    }];\n\n    // Set initial target\n    this.targetEnemyY = firstLaserY;\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score) {\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reset speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      this.baseSpeed = BASE_LASER_SPEED;\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      const newLaserY = this.generateRandomLaserY();\n      this.lasers.push({\n        x: this.enemyX + BALL_SIZE / 2,\n        // Spawn from enemy center X\n        y: newLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: this.generateRandomLaserY()\n      });\n    }\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   */\n  getCurrentSpeed(score) {\n    const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT) % SPEED_INCREMENTS_PER_CYCLE;\n    return this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */\n  update(score, playerPosition, playerHasJumped) {\n    const currentSpeed = this.getCurrentSpeed(score);\n    let scoreChange = 0;\n    let wasHit = false;\n    this.lasers.forEach(laser => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      if (laser.x + LASER_WIDTH < 0) {\n        // Spawn laser from enemy's current center position\n        laser.x = this.enemyX + BALL_SIZE / 2;\n        laser.y = this.enemyY + BALL_SIZE / 2; // Spawn from enemy's current center Y\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n\n        // Calculate the NEXT spawn position\n        laser.nextY = this.generateRandomLaserY();\n\n        // IMMEDIATELY start moving to next position (don't wait!)\n        this.targetEnemyY = laser.nextY;\n      }\n\n      // Check collision with player\n      if (!laser.hit && playerPosition.x + BALL_SIZE > laser.x && playerPosition.x < laser.x + LASER_WIDTH && playerPosition.y + BALL_SIZE > laser.y && playerPosition.y < laser.y + LASER_HEIGHT) {\n        laser.hit = true;\n        wasHit = true;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (!laser.scored && !laser.hit && playerHasJumped && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    // Smoothly interpolate enemy Y position every frame\n    // Enemy is always moving toward targetEnemyY\n    const previousY = this.enemyY;\n    this.enemyY += (this.targetEnemyY - this.enemyY) * ENEMY_MOVE_SPEED;\n\n    // Calculate velocity for squash/stretch effect\n    this.enemyVelocity = this.enemyY - previousY;\n    return {\n      scoreChange,\n      wasHit\n    };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers() {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers() {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position (smoothly animated)\n   */\n  getEnemyY() {\n    return this.enemyY;\n  }\n\n  /**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   */\n  getEnemyScale() {\n    // Calculate squash/stretch based on velocity\n    // Moving down (positive velocity) = stretch vertically\n    // Moving up (negative velocity) = stretch horizontally\n\n    const velocityFactor = Math.abs(this.enemyVelocity) * 2; // Amplify for visibility\n\n    let scaleX = 1;\n    let scaleY = 1;\n    if (Math.abs(this.enemyVelocity) > 0.1) {\n      if (this.enemyVelocity > 0) {\n        // Moving down - stretch vertically, squash horizontally\n        scaleY = 1 + velocityFactor;\n        scaleX = 1 - velocityFactor * 0.5;\n      } else {\n        // Moving up - stretch horizontally, squash vertically\n        scaleX = 1 + velocityFactor;\n        scaleY = 1 - velocityFactor * 0.5;\n      }\n    }\n\n    // Clamp values to reasonable ranges\n    scaleX = Math.max(0.7, Math.min(1.3, scaleX));\n    scaleY = Math.max(0.7, Math.min(1.3, scaleY));\n    return {\n      scaleX,\n      scaleY\n    };\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset() {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.targetEnemyY = this.centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth, screenHeight, centerY, enemyX) {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyX = enemyX;\n  }\n}","map":{"version":3,"names":["LASER_WIDTH","LASER_HEIGHT","BASE_LASER_SPEED","LASER_SPEED_INCREMENT","MAX_LASERS","SCORE_PER_LASER_UNLOCK","SCORE_PER_SPEED_INCREMENT","SPEED_INCREMENTS_PER_CYCLE","BALL_SIZE","ENEMY_MOVE_SPEED","LaserPhysics","constructor","screenWidth","screenHeight","centerY","enemyX","lasers","numLasers","baseSpeed","enemyY","targetEnemyY","enemyVelocity","minLaserY","initializeLasers","generateRandomLaserY","Math","random","firstLaserY","nextLaserY","x","y","hit","scored","passed","nextY","updateLaserCount","score","extraLasers","floor","prevNumLasers","min","length","newLaserY","push","pop","getCurrentSpeed","speedIncrements","update","playerPosition","playerHasJumped","currentSpeed","scoreChange","wasHit","forEach","laser","previousY","getLasers","getNumLasers","getEnemyY","getEnemyScale","velocityFactor","abs","scaleX","scaleY","max","reset","updateDimensions"],"sources":["/Users/OCSAdmin/Projects/geminiTut/my-react-app/src/systems/laserPhysics.ts"],"sourcesContent":["/**\n * Laser Physics System\n * Handles laser movement, collision detection, spawning, and scoring\n * Features smooth enemy movement that continuously moves between positions\n * Lasers spawn from the center of the enemy ball\n */\n\nimport { LaserState, Position } from '../types/game';\nimport {\n  LASER_WIDTH,\n  LASER_HEIGHT,\n  BASE_LASER_SPEED,\n  LASER_SPEED_INCREMENT,\n  MAX_LASERS,\n  SCORE_PER_LASER_UNLOCK,\n  SCORE_PER_SPEED_INCREMENT,\n  SPEED_INCREMENTS_PER_CYCLE,\n  BALL_SIZE,\n  ENEMY_MOVE_SPEED,\n} from '../config/gameConfig';\n\nexport class LaserPhysics {\n  private lasers: LaserState[] = [];\n  private numLasers: number = 1;\n  private baseSpeed: number = BASE_LASER_SPEED;\n  private enemyY: number;\n  private targetEnemyY: number; // Target Y position for smooth movement\n  private enemyVelocity: number = 0; // Track movement velocity for squash/stretch\n  private centerY: number;\n  private minLaserY: number;\n  private enemyX: number;\n\n  constructor(screenWidth: number, screenHeight: number, centerY: number, enemyX: number) {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyY = centerY;\n    this.targetEnemyY = centerY;\n    this.enemyX = enemyX;\n    this.initializeLasers();\n  }\n\n  /**\n   * Generate a random Y position for laser spawn\n   * Adjusted to account for ball size so laser comes from center\n   */\n  private generateRandomLaserY(): number {\n    return Math.random() * (this.centerY - this.minLaserY) + this.minLaserY;\n  }\n\n  /**\n   * Initialize lasers at starting positions\n   */\n  private initializeLasers(): void {\n    const firstLaserY = this.centerY;\n    const nextLaserY = this.generateRandomLaserY();\n\n    this.lasers = [\n      {\n        x: this.enemyX + BALL_SIZE / 2, // Spawn from enemy center X\n        y: firstLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: nextLaserY, // Pre-calculate next position\n      },\n    ];\n\n    // Set initial target\n    this.targetEnemyY = firstLaserY;\n  }\n\n  /**\n   * Update laser count based on score\n   */\n  updateLaserCount(score: number): void {\n    const extraLasers = Math.floor(score / SCORE_PER_LASER_UNLOCK);\n    const prevNumLasers = this.numLasers;\n    this.numLasers = Math.min(extraLasers + 1, MAX_LASERS);\n\n    // Reset speed when new laser is added\n    if (this.numLasers > prevNumLasers) {\n      this.baseSpeed = BASE_LASER_SPEED;\n    }\n\n    // Adjust laser array\n    while (this.lasers.length < this.numLasers) {\n      const newLaserY = this.generateRandomLaserY();\n      this.lasers.push({\n        x: this.enemyX + BALL_SIZE / 2, // Spawn from enemy center X\n        y: newLaserY,\n        hit: false,\n        scored: false,\n        passed: false,\n        nextY: this.generateRandomLaserY(),\n      });\n    }\n\n    while (this.lasers.length > this.numLasers) {\n      this.lasers.pop();\n    }\n  }\n\n  /**\n   * Calculate current laser speed based on score\n   */\n  private getCurrentSpeed(score: number): number {\n    const speedIncrements = Math.floor(score / SCORE_PER_SPEED_INCREMENT) % SPEED_INCREMENTS_PER_CYCLE;\n    return this.baseSpeed + LASER_SPEED_INCREMENT * speedIncrements;\n  }\n\n  /**\n   * Update all lasers for one frame\n   * Returns score change and hit status\n   */\n  update(\n    score: number,\n    playerPosition: Position,\n    playerHasJumped: boolean\n  ): { scoreChange: number; wasHit: boolean } {\n    const currentSpeed = this.getCurrentSpeed(score);\n    let scoreChange = 0;\n    let wasHit = false;\n\n    this.lasers.forEach((laser) => {\n      // Move laser\n      laser.x -= currentSpeed;\n\n      // Check if player passed without jumping (penalty)\n      if (!laser.hit && !laser.passed && playerPosition.x > laser.x + LASER_WIDTH) {\n        laser.passed = true;\n        if (!playerHasJumped) {\n          scoreChange -= 1;\n        }\n      }\n\n      // Respawn laser when off screen\n      if (laser.x + LASER_WIDTH < 0) {\n        // Spawn laser from enemy's current center position\n        laser.x = this.enemyX + BALL_SIZE / 2;\n        laser.y = this.enemyY + BALL_SIZE / 2; // Spawn from enemy's current center Y\n        laser.hit = false;\n        laser.scored = false;\n        laser.passed = false;\n\n        // Calculate the NEXT spawn position\n        laser.nextY = this.generateRandomLaserY();\n\n        // IMMEDIATELY start moving to next position (don't wait!)\n        this.targetEnemyY = laser.nextY;\n      }\n\n      // Check collision with player\n      if (\n        !laser.hit &&\n        playerPosition.x + BALL_SIZE > laser.x &&\n        playerPosition.x < laser.x + LASER_WIDTH &&\n        playerPosition.y + BALL_SIZE > laser.y &&\n        playerPosition.y < laser.y + LASER_HEIGHT\n      ) {\n        laser.hit = true;\n        wasHit = true;\n      }\n\n      // Check if player successfully jumped over laser (scoring)\n      if (\n        !laser.scored &&\n        !laser.hit &&\n        playerHasJumped &&\n        playerPosition.x > laser.x + LASER_WIDTH\n      ) {\n        laser.scored = true;\n        scoreChange += 1;\n      }\n    });\n\n    // Smoothly interpolate enemy Y position every frame\n    // Enemy is always moving toward targetEnemyY\n    const previousY = this.enemyY;\n    this.enemyY += (this.targetEnemyY - this.enemyY) * ENEMY_MOVE_SPEED;\n\n    // Calculate velocity for squash/stretch effect\n    this.enemyVelocity = this.enemyY - previousY;\n\n    return { scoreChange, wasHit };\n  }\n\n  /**\n   * Get all laser states\n   */\n  getLasers(): LaserState[] {\n    return this.lasers;\n  }\n\n  /**\n   * Get current number of active lasers\n   */\n  getNumLasers(): number {\n    return this.numLasers;\n  }\n\n  /**\n   * Get enemy Y position (smoothly animated)\n   */\n  getEnemyY(): number {\n    return this.enemyY;\n  }\n\n  /**\n   * Get enemy squash/stretch scale based on movement velocity\n   * Returns { scaleX, scaleY } for morphing effect\n   */\n  getEnemyScale(): { scaleX: number; scaleY: number } {\n    // Calculate squash/stretch based on velocity\n    // Moving down (positive velocity) = stretch vertically\n    // Moving up (negative velocity) = stretch horizontally\n\n    const velocityFactor = Math.abs(this.enemyVelocity) * 2; // Amplify for visibility\n\n    let scaleX = 1;\n    let scaleY = 1;\n\n    if (Math.abs(this.enemyVelocity) > 0.1) {\n      if (this.enemyVelocity > 0) {\n        // Moving down - stretch vertically, squash horizontally\n        scaleY = 1 + velocityFactor;\n        scaleX = 1 - velocityFactor * 0.5;\n      } else {\n        // Moving up - stretch horizontally, squash vertically\n        scaleX = 1 + velocityFactor;\n        scaleY = 1 - velocityFactor * 0.5;\n      }\n    }\n\n    // Clamp values to reasonable ranges\n    scaleX = Math.max(0.7, Math.min(1.3, scaleX));\n    scaleY = Math.max(0.7, Math.min(1.3, scaleY));\n\n    return { scaleX, scaleY };\n  }\n\n  /**\n   * Reset laser system\n   */\n  reset(): void {\n    this.numLasers = 1;\n    this.baseSpeed = BASE_LASER_SPEED;\n    this.enemyY = this.centerY;\n    this.targetEnemyY = this.centerY;\n    this.initializeLasers();\n  }\n\n  /**\n   * Update dimensions (for window resize)\n   */\n  updateDimensions(screenWidth: number, screenHeight: number, centerY: number, enemyX: number): void {\n    this.centerY = centerY;\n    this.minLaserY = screenHeight * 0.5;\n    this.enemyX = enemyX;\n  }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}